<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="RepoLite.Common.Models" #>
<#@ import namespace="System.Xml" #>
<# var pk = generationObject.Table.PrimaryKeys.FirstOrDefault();#>
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using Biomind.Data.Repositories.Base;
using Biomind.Data.Models;
using Biomind.Data.Models.Base;
using System;
using System.Collections.Generic;
using System.Data;
using System.Data.SqlClient;
using System.IO;
using System.Linq;
using System.Xml;

namespace <#= generationSettings.RepositoryGenerationNamespace #>
{
    public partial interface I<#= generationObject.Table.RepositoryName #> : IPkRepository<<#=generationObject.Table.ClassName #>>
    {
        IEnumerable<<#=generationObject.Table.ClassName #>> ExecuteSql(string sql);

		<#=generationObject.Table.ClassName #> Get(<#= pk.DataTypeString #> <#= pk.FieldName #>);
		<#=generationObject.Table.ClassName #> Get(<#= pk.DataTypeString #> <#= pk.FieldName #>, bool skipCache);
		IEnumerable<<#=generationObject.Table.ClassName #>> Get(List<<#= pk.DataTypeString #>> <#= pk.FieldName #>s);
		IEnumerable<<#=generationObject.Table.ClassName #>> Get(List<<#= pk.DataTypeString #>> <#= pk.FieldName #>s, bool skipCache);
		IEnumerable<<#=generationObject.Table.ClassName #>> Get(params <#= pk.DataTypeString #>[] <#= pk.FieldName #>s);
		
        <#= pk.DataTypeString #> GetMaxId();
		bool Delete(<#= pk.DataTypeString #> <#= pk.FieldName #>);
		bool Delete(IEnumerable<<#= pk.DataTypeString #>> <#= pk.FieldName #>s);

<#= AppendInheritanceLogic(generationObject,(column, rgo) =>
                $"\t\tbool DeleteBy{column.DbColumnName}({column.DataTypeString} {column.FieldName});\n")#>

        IEnumerable<<#=generationObject.Table.ClassName #>> Search(
<#= AppendInheritanceLogic(generationObject,(column, rgo) =>
    {
        var isb = new StringBuilder();
        isb.Append(column.DataType != typeof(XmlDocument)
                ? $"\t\t\t{column.DataTypeString}{(IsCSharpNullable(column.DataTypeString) ? "?" : string.Empty)} {column.FieldName} = null"
                : $"\t\t\tString {column.FieldName} = null");
        
        if (rgo.InheritedDependency != null || column != rgo.Table.Columns.Last())
                isb.AppendLine(",");
        
        return isb.ToString();
    })#>

<#= AppendInheritanceLogic(generationObject, (column, rgo) =>
    {
        var isb = new StringBuilder();
        isb.AppendLine(
            column.DataType != typeof(XmlDocument)
                ? $"\t\tIEnumerable<{rgo.Table.ClassName}> FindBy{column.PropertyName}({column.DataTypeString} {column.FieldName});"
                : $"\t\tIEnumerable<{rgo.Table.ClassName}> FindBy{column.PropertyName}(String {column.FieldName});");

        isb.AppendLine(
            column.DataType != typeof(XmlDocument)
                ? $"\t\tIEnumerable<{rgo.Table.ClassName}> FindBy{column.PropertyName}({column.DataTypeString} {column.FieldName}, bool skipCache);"
                : $"\t\tIEnumerable<{rgo.Table.ClassName}> FindBy{column.PropertyName}(String {column.FieldName}, bool skipCache);");

        isb.AppendLine(
            column.DataType != typeof(XmlDocument)
                ? $"\t\tIEnumerable<{rgo.Table.ClassName}> FindBy{column.PropertyName}(FindComparison comparison, {column.DataTypeString} {column.FieldName});"
                : $"\t\tIEnumerable<{rgo.Table.ClassName}> FindBy{column.PropertyName}(FindComparison comparison, String {column.FieldName});");

        isb.AppendLine(
            column.DataType != typeof(XmlDocument)
                ? $"\t\tIEnumerable<{rgo.Table.ClassName}> FindBy{column.PropertyName}(FindComparison comparison, {column.DataTypeString} {column.FieldName}, bool skipCache);"
                : $"\t\tIEnumerable<{rgo.Table.ClassName}> FindBy{column.PropertyName}(FindComparison comparison, String {column.FieldName}, bool skipCache);");
        return isb.ToString();
    })#>
        );
    }
}

<#
string AppendInheritanceLogic(RepositoryGenerationObject generationObject, Func<Column, RepositoryGenerationObject, string> getInheritancelogic)
{
    var sb = new StringBuilder();
    
    foreach (
        var column in
            generationObject.Table.Columns.Where(
                inheritedColumn =>
                    !inheritedColumn.PrimaryKey &&
                    (generationObject.InheritedDependency == null ||
                     inheritedColumn.DbColumnName != generationObject.InheritedDependency.DbColumnName)))
    {
        sb.Append(getInheritancelogic(column, generationObject));
    }
    
    if (generationObject.InheritedDependency != null)
    {
        sb.Append(AppendInheritanceLogic(generationObject.InheritedTable, getInheritancelogic));
    }
    return sb.ToString();
}
bool IsCSharpNullable(string type)
{
    return type != "byte[]" && type != "object" && type != "string" && type != "XmlDocument" &&
           type != "Byte[]" && type != "Object" && type != "String";
}
#>