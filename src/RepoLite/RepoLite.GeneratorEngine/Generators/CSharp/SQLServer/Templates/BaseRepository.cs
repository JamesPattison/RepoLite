// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version: 16.0.0.0
//  
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------
namespace RepoLite.GeneratorEngine.Generators.CSharp.SQLServer.Templates
{
    using System;
    
    /// <summary>
    /// Class to produce the template output
    /// </summary>
    
    #line 1 "C:\Users\Jimmy\source\repos\RepoLite\src\RepoLite\RepoLite.GeneratorEngine\Generators\CSharp\SQLServer\Templates\BaseRepository.tt"
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.VisualStudio.TextTemplating", "16.0.0.0")]
    public partial class BaseRepository : BaseRepositoryBase
    {
#line hidden
        /// <summary>
        /// Create the template output
        /// </summary>
        public virtual string TransformText()
        {
            this.Write("//------------------------------------------------------------------------------\r\n// <auto-generated>\r\n//     This code was generated by a tool.\r\n//\r\n//     Changes to this file may cause incorrect behavior and will be lost if\r\n//     the code is regenerated.\r\n// </auto-generated>\r\n//------------------------------------------------------------------------------\r\nusing ");
            
            #line 10 "C:\Users\Jimmy\source\repos\RepoLite\src\RepoLite\RepoLite.GeneratorEngine\Generators\CSharp\SQLServer\Templates\BaseRepository.tt"
            this.Write(this.ToStringHelper.ToStringWithCulture(generationSettings.ModelGenerationNamespace));
            
            #line default
            #line hidden
            this.Write(";\r\nusing ");
            
            #line 11 "C:\Users\Jimmy\source\repos\RepoLite\src\RepoLite\RepoLite.GeneratorEngine\Generators\CSharp\SQLServer\Templates\BaseRepository.tt"
            this.Write(this.ToStringHelper.ToStringWithCulture(generationSettings.ModelGenerationNamespace));
            
            #line default
            #line hidden
            this.Write(".Base;\r\nusing System;\r\nusing System.Collections;\r\nusing System.Collections.Generic;\r\nusing System.Data;\r\nusing System.Data.SqlClient;\r\nusing System.Linq;\r\nusing System.Linq.Expressions;\r\nusing System.Reflection;\r\n");
            
            #line 20 "C:\Users\Jimmy\source\repos\RepoLite\src\RepoLite\RepoLite.GeneratorEngine\Generators\CSharp\SQLServer\Templates\BaseRepository.tt"
 if (generationSettings.IncludeCaching) { 
            
            #line default
            #line hidden
            this.Write("using System.Runtime.Caching;\r\n");
            
            #line 22 "C:\Users\Jimmy\source\repos\RepoLite\src\RepoLite\RepoLite.GeneratorEngine\Generators\CSharp\SQLServer\Templates\BaseRepository.tt"
 } 
            
            #line default
            #line hidden
            this.Write("using System.Runtime.CompilerServices;\r\nusing System.Text;\r\nusing System.Xml;\r\n\r\nnamespace ");
            
            #line 27 "C:\Users\Jimmy\source\repos\RepoLite\src\RepoLite\RepoLite.GeneratorEngine\Generators\CSharp\SQLServer\Templates\BaseRepository.tt"
            this.Write(this.ToStringHelper.ToStringWithCulture(generationSettings.RepositoryGenerationNamespace));
            
            #line default
            #line hidden
            this.Write(".Base\r\n{\r\n    public partial interface IBaseRepository<T> : IJoinable<T>\r\n        where T : IBaseModel, new()\r\n    {\r\n        long RecordCount();\r\n        IEnumerable<T> GetAll();\r\n        bool Create(T item);\r\n        bool BulkCreate(List<T> items);\r\n        bool BulkCreate(params T[] items);\r\n\r\n        Where<T> Where(string col, Comparison comparison, object val);\r\n        Where<T> Where(string col, Comparison comparison, object val, Type valueType);\r\n        IEnumerable<T> Where(string query);\r\n        T ToItem(DataRow row, bool skipBase);\r\n        TK ToItem<TK>(DataRow row, bool skipBase) where TK : T, new();\r\n");
            
            #line 43 "C:\Users\Jimmy\source\repos\RepoLite\src\RepoLite\RepoLite.GeneratorEngine\Generators\CSharp\SQLServer\Templates\BaseRepository.tt"
 if (generationSettings.IncludeCaching) { 
            
            #line default
            #line hidden
            this.Write("        void EnableCache(int cacheDurationInSeconds);\r\n");
            
            #line 45 "C:\Users\Jimmy\source\repos\RepoLite\src\RepoLite\RepoLite.GeneratorEngine\Generators\CSharp\SQLServer\Templates\BaseRepository.tt"
 } 
            
            #line default
            #line hidden
            this.Write("        IEnumerable<T> ExecuteSql(string sql);\r\n    }\r\n\r\n    public interface IPkRepository<T> : IBaseRepository<T>\r\n        where T : IBaseModel, new()\r\n    {\r\n        bool Update(T item, bool clearDirty = true);\r\n        bool Delete(T item);\r\n        bool Delete(IEnumerable<T> items);\r\n        bool Merge(List<T> items);\r\n        bool Merge(string csvPath);\r\n    }\r\n\r\n    #region Enums\r\n\r\n    internal enum ClauseType\r\n    {\r\n        Initial,\r\n        And,\r\n        Or\r\n    }\r\n\r\n    public enum FindComparison\r\n    {\r\n        Equals,\r\n        NotEquals,\r\n        Like,\r\n        NotLike,\r\n        GreaterThan,\r\n        GreaterThanOrEquals,\r\n        LessThan,\r\n        LessThanOrEquals,\r\n    }\r\n\r\n    public enum Comparison\r\n    {\r\n        Equals,\r\n        NotEquals,\r\n        Like,\r\n        NotLike,\r\n        GreaterThan,\r\n        GreaterThanOrEquals,\r\n        LessThan,\r\n        LessThanOrEquals,\r\n        In,\r\n        NotIn,\r\n        IsNull,\r\n        IsNotNull\r\n    }\r\n\r\n    #endregion\r\n\r\n    #region Models\r\n\r\n    public class DeleteColumn\r\n    {\r\n        public string ColumnName { get; set; }\r\n        public SqlDbType SqlDbType { get; set; }\r\n        public object Data { get; set; }\r\n\r\n        public DeleteColumn(string columnName, object data, SqlDbType dbType)\r\n        {\r\n            ColumnName = columnName;\r\n            Data = data;\r\n            SqlDbType = dbType;\r\n        }\r\n    }\r\n\r\n    public class QueryItem\r\n    {\r\n        public string DbColumnName { get; set; }\r\n        public object Value { get; set; }\r\n        public Type DataType { get; set; }\r\n\r\n        public QueryItem(string dbColName, object value) : this(dbColName, value, value.GetType()) { }\r\n\r\n        public QueryItem(string dbColName, object value, Type dataType)\r\n        {\r\n            DbColumnName = dbColName;\r\n            Value = value;\r\n            DataType = dataType;\r\n        }\r\n    }\r\n\r\n    public class ValidationException : Exception\r\n    {\r\n        public List<ValidationError> ValidationErrors { get; set; }\r\n\r\n        public ValidationException(List<ValidationError> validationErrors)\r\n        {\r\n            ValidationErrors = validationErrors;\r\n        }\r\n    }\r\n\r\n    #endregion\r\n\r\n    #region Where\r\n\r\n    public class Where<T>\r\n        where T : IBaseModel, new()\r\n    {\r\n        private readonly StringBuilder _query = new StringBuilder();\r\n        private readonly BaseRepository<T> _repository;\r\n        private int _activeGroups;\r\n        private List<TableDefinition> _tables;\r\n\r\n        public Where(BaseRepository<T> baseRepository, List<TableDefinition> tables, string col, Comparison comparison, object val) : this(\r\n            baseRepository, tables, col, comparison, val, val.GetType())\r\n        { }\r\n\r\n        public Where(BaseRepository<T> baseRepository, List<TableDefinition> tables, string col, Comparison comparison, object val, Type valueType)\r\n        {\r\n            _repository = baseRepository;\r\n            _tables = tables;\r\n\r\n            _query.Append(MakeClause(col, comparison, val, ClauseType.Initial, valueType));\r\n        }\r\n\r\n        private string MakeClause(string col, Comparison comparison, ClauseType clauseType)\r\n        {\r\n            return MakeClause(col, comparison, null, clauseType, null);\r\n        }\r\n\r\n        private string MakeClause(string col, Comparison comparison, object val, ClauseType clauseType, Type valueType)\r\n        {\r\n            var query = new StringBuilder();\r\n\r\n            var tableIndex = _tables.IndexOf(_tables.Find(x => x.Columns.Any(y => y.ColumnName == col)));\r\n\r\n            switch (comparison)\r\n            {\r\n                case Comparison.In:\r\n                case Comparison.NotIn:\r\n                    if (val is IEnumerable list && !(val as object[] ?? (val as IEnumerable).Cast<object>().ToArray()).Any())\r\n                    {\r\n                        //No elements in list, append a clause which will return no values\r\n                        query.Append(\"1=0\");\r\n                        return query.ToString();\r\n                    }\r\n\r\n                    break;\r\n            }\r\n\r\n            float floatVal;\r\n            if (new[]\r\n                {\r\n                    Comparison.GreaterThan, Comparison.GreaterThanOrEquals, Comparison.LessThan,\r\n                    Comparison.LessThanOrEquals\r\n                }.Contains(comparison)\r\n                && !float.TryParse(val.ToString(), out floatVal))\r\n                throw new Exception(\"Numeric comparison used on a non numeric value.\");\r\n\r\n            switch (clauseType)\r\n            {\r\n                case ClauseType.Initial:\r\n                    query.Append(valueType == typeof(XmlDocument)\r\n                        ? $\"CONVERT(NVARCHAR(MAX), a_{tableIndex}.[{col}])\"\r\n                        : $\"a_{tableIndex}.[{col}]\");\r\n                    break;\r\n                case ClauseType.And:\r\n                    query.Append(valueType == typeof(XmlDocument)\r\n                        ? $\" AND CONVERT(NVARCHAR(MAX), a_{tableIndex}.[{col}])\"\r\n                        : $\" AND a_{tableIndex}.[{col}]\");\r\n                    break;\r\n                case ClauseType.Or:\r\n                    query.Append(valueType == typeof(XmlDocument)\r\n                        ? $\" OR CONVERT(NVARCHAR(MAX), a_{tableIndex}.[{col}])\"\r\n                        : $\" OR a_{tableIndex}.[{col}]\");\r\n                    break;\r\n            }\r\n\r\n            query.Append(GetComparison(comparison));\r\n            if (comparison != Comparison.IsNull && comparison != Comparison.IsNotNull)\r\n            {\r\n                var typeVal = GetTypeVal(col, val);\r\n\r\n                if (comparison == Comparison.Like || comparison == Comparison.NotLike)\r\n                    typeVal = typeVal.TrimStart('\\'').TrimEnd('\\'');\r\n\r\n                query.Append(typeVal);\r\n            }\r\n\r\n            switch (comparison)\r\n            {\r\n                case Comparison.In:\r\n                case Comparison.NotIn:\r\n                    query.Append(\")\");\r\n                    break;\r\n                case Comparison.Like:\r\n                case Comparison.NotLike:\r\n                    query.Append(\"%'\");\r\n                    break;\r\n            }\r\n\r\n            return query.ToString();\r\n        }\r\n\r\n        private static string GetComparison(Comparison comparison)\r\n        {\r\n            switch (comparison)\r\n            {\r\n                case Comparison.Equals:\r\n                    return \" = \";\r\n                case Comparison.NotEquals:\r\n                    return \" <> \";\r\n                case Comparison.Like:\r\n                    return \" LIKE '%\";\r\n                case Comparison.NotLike:\r\n                    return \" NOT LIKE '%\";\r\n                case Comparison.GreaterThan:\r\n                    return \" > \";\r\n                case Comparison.GreaterThanOrEquals:\r\n                    return \" >= \";\r\n                case Comparison.LessThan:\r\n                    return \" < \";\r\n                case Comparison.LessThanOrEquals:\r\n                    return \" <= \";\r\n                case Comparison.In:\r\n                    return \" IN (\";\r\n                case Comparison.NotIn:\r\n                    return \" NOT IN (\";\r\n                case Comparison.IsNull:\r\n                    return \" IS NULL\";\r\n                case Comparison.IsNotNull:\r\n                    return \" IS NOT NULL\";\r\n                default:\r\n                    throw new NotSupportedException(\"???\");\r\n            }\r\n        }\r\n\r\n        private string GetTypeVal(string col, object val)\r\n        {\r\n            var typeName = val is IList ? \"List\" : val.GetType().Name;\r\n            switch (typeName)\r\n            {\r\n                case \"Boolean\":\r\n                    if ((bool)val)\r\n                        return \"1\";\r\n                    return \"0\";\r\n                case \"Int16\":\r\n                case \"UInt16\":\r\n                case \"Int32\":\r\n                case \"UInt32\":\r\n                case \"Int64\":\r\n                case \"UInt64\":\r\n                case \"Decimal\":\r\n                case \"Double\":\r\n                    return val.ToString();\r\n                case \"DateTime\":\r\n                case \"Char\":\r\n                case \"String\":\r\n                case \"Guid\":\r\n                case \"TimeSpan\":\r\n                case \"DateTimeOffset\":\r\n                    return \"'\" + val + \"'\";\r\n                case \"List\":\r\n                    var result = \"\";\r\n\r\n                    var enumerable = val as object[] ?? (val as IEnumerable).Cast<object>().ToArray();\r\n\r\n                    const int batchSize = 2000;\r\n                    var batches = Math.Ceiling((decimal)enumerable.Length / batchSize);\r\n                    for (var i = 0; i < batches; i++)\r\n                    {\r\n                        result = enumerable\r\n                            .Skip(i * batchSize)\r\n                            .Take(batchSize)\r\n                            .Aggregate(result, (current, o) => current + GetTypeVal(col, o) + \", \")\r\n                            .TrimEnd(' ')\r\n                            .TrimEnd(',');\r\n\r\n                        if (batches > i + 1)\r\n                            result += \") OR [\" + col + \"] IN (\";\r\n                    }\r\n\r\n                    return result;\r\n                default:\r\n                    throw new NotSupportedException(\"Not supported yet\");\r\n            }\r\n        }\r\n\r\n        public IEnumerable<T> Results()\r\n        {\r\n            if (_activeGroups > 0) throw new Exception(\"Please close all Query Groups before calling Results()\");\r\n            return _repository.Where(_tables, _query.ToString());\r\n        }\r\n\r\n        public Where<T> And(string col, Comparison comparison)\r\n        {\r\n            if (comparison != Comparison.IsNull && comparison != Comparison.IsNotNull)\r\n                throw new Exception(\"And(\" + col + \", \" + comparison + \") can only be called with Comparison.IsNull or Comparison.IsNotNull\");\r\n            _query.Append(MakeClause(col, comparison, ClauseType.And));\r\n            return this;\r\n        }\r\n\r\n        public Where<T> And(string col, Comparison comparison, object val)\r\n        {\r\n            return And(col, comparison, val, val.GetType());\r\n        }\r\n\r\n        public Where<T> And(string col, Comparison comparison, object val, Type valueType)\r\n        {\r\n            _query.Append(MakeClause(col, comparison, val, ClauseType.And, valueType));\r\n            return this;\r\n        }\r\n\r\n        public Where<T> Or(string col, Comparison comparison)\r\n        {\r\n            if (comparison != Comparison.IsNull && comparison != Comparison.IsNotNull)\r\n                throw new Exception(\"Or(\" + col + \", \" + comparison + \") can only be called with Comparison.IsNull or Comparison.IsNotNull\");\r\n\r\n            _query.Append(MakeClause(col, comparison, ClauseType.Or));\r\n            return this;\r\n        }\r\n\r\n        public Where<T> Or(string col, Comparison comparison, object val)\r\n        {\r\n            return Or(col, comparison, val, val.GetType());\r\n        }\r\n\r\n        public Where<T> Or(string col, Comparison comparison, object val, Type valueType)\r\n        {\r\n            _query.Append(MakeClause(col, comparison, val, ClauseType.Or, valueType));\r\n            return this;\r\n        }\r\n\r\n        public Where<T> AndBeginGroup(string col, Comparison comparison)\r\n        {\r\n            if (comparison != Comparison.IsNull && comparison != Comparison.IsNotNull)\r\n                throw new Exception(\"AndBeginGroup(\" + col + \", \" + comparison + \") can only be called with Comparison.IsNull or Comparison.IsNotNull\");\r\n\r\n            _activeGroups++;\r\n            _query.Append(\" AND (\" + MakeClause(col, comparison, ClauseType.Initial));\r\n            return this;\r\n        }\r\n\r\n        public Where<T> AndBeginGroup(string col, Comparison comparison, object val)\r\n        {\r\n            return AndBeginGroup(col, comparison, val, val.GetType());\r\n        }\r\n\r\n        public Where<T> AndBeginGroup(string col, Comparison comparison, object val, Type valueType)\r\n        {\r\n            _activeGroups++;\r\n            _query.Append(\" AND (\" + MakeClause(col, comparison, val, ClauseType.Initial, valueType));\r\n            return this;\r\n        }\r\n\r\n        public Where<T> OrBeginGroup(string col, Comparison comparison)\r\n        {\r\n            if (comparison != Comparison.IsNull && comparison != Comparison.IsNotNull)\r\n                throw new Exception(\"OrBeginGroup(\" + col + \", \" + comparison + \") can only be called with Comparison.IsNull or Comparison.IsNotNull\");\r\n\r\n            _activeGroups++;\r\n            _query.Append(\" OR (\" + MakeClause(col, comparison, ClauseType.Initial));\r\n            return this;\r\n        }\r\n\r\n        public Where<T> OrBeginGroup(string col, Comparison comparison, object val)\r\n        {\r\n            return OrBeginGroup(col, comparison, val, val.GetType());\r\n        }\r\n\r\n        public Where<T> OrBeginGroup(string col, Comparison comparison, object val, Type valueType)\r\n        {\r\n            _activeGroups++;\r\n            _query.Append(\" OR (\" + MakeClause(col, comparison, val, ClauseType.Initial, valueType));\r\n            return this;\r\n        }\r\n\r\n        public Where<T> EndGroup()\r\n        {\r\n            _activeGroups--;\r\n            _query.Append(\")\");\r\n            return this;\r\n        }\r\n    }\r\n\r\n    #endregion\r\n\r\n    #region ExpressionParser\r\n\r\n    internal static class ExpressionParser\r\n    {\r\n        private static readonly Dictionary<ExpressionType, string> NodeStr = new Dictionary<ExpressionType, string>\r\n        {\r\n            {ExpressionType.Add, \"+\"},\r\n            {ExpressionType.And, \"&\"},\r\n            {ExpressionType.AndAlso, \"AND\"},\r\n            {ExpressionType.Convert, \"\"},\r\n            {ExpressionType.Divide, \"/\"},\r\n            {ExpressionType.Equal, \"=\"},\r\n            {ExpressionType.ExclusiveOr, \"^\"},\r\n            {ExpressionType.GreaterThan, \">\"},\r\n            {ExpressionType.GreaterThanOrEqual, \">=\"},\r\n            {ExpressionType.LessThan, \"<\"},\r\n            {ExpressionType.LessThanOrEqual, \"<=\"},\r\n            {ExpressionType.Modulo, \"%\"},\r\n            {ExpressionType.Multiply, \"*\"},\r\n            {ExpressionType.Negate, \"-\"},\r\n            {ExpressionType.Not, \"NOT\"},\r\n            {ExpressionType.NotEqual, \"<>\"},\r\n            {ExpressionType.Or, \"|\"},\r\n            {ExpressionType.OrElse, \"OR\"},\r\n            {ExpressionType.Subtract, \"-\"}\r\n        };\r\n\r\n        internal static string ToSql(LambdaExpression expression, Dictionary<string, string> xRef)\r\n        {\r\n            return Parse(expression.Body, xRef, true).Sql;\r\n        }\r\n\r\n        internal static string ToSql<T>(Expression<Func<T, bool>> expression, Dictionary<string, string> xRef)\r\n            where T : IBaseModel, new()\r\n        {\r\n            return ToSql((LambdaExpression)expression, xRef);\r\n        }\r\n\r\n        internal static string ToSql<T, TK>(Expression<Func<T, TK, bool>> expression, Dictionary<string, string> xRef)\r\n            where T : IBaseModel, new()\r\n            where TK : IBaseModel, new()\r\n        {\r\n            return ToSql((LambdaExpression)expression, xRef);\r\n        }\r\n\r\n        private static Clause Parse(Expression expression, Dictionary<string, string> xRef, bool isUnary = false, string prefix = null, string postfix = null, bool boolComparison = false)\r\n        {\r\n            while (true)\r\n            {\r\n                switch (expression)\r\n                {\r\n                    case UnaryExpression unary:\r\n                        return Clause.Make(NodeStr[unary.NodeType], Parse(unary.Operand, xRef, true));\r\n                    case BinaryExpression body:\r\n                        var leftValue = Parse(body.Left, xRef);\r\n\r\n                        var rightValue = Parse(body.Right, xRef);\r\n\r\n                        return Clause.Make(leftValue, NodeStr[body.NodeType], rightValue);\r\n                    case ConstantExpression constant:\r\n                        {\r\n                            var value = constant.Value;\r\n                            switch (value)\r\n                            {\r\n                                case int _:\r\n                                    return Clause.Make(value.ToString());\r\n                                case string _:\r\n                                    value = prefix + (string)value + postfix;\r\n                                    break;\r\n                            }\r\n\r\n                            if (value is bool && isUnary)\r\n                            {\r\n                                return boolComparison ? Clause.Make($\"'{value}'\") : Clause.Make(Clause.Make($\"'{value}'\"), \"=\", Clause.Make(\"1\"));\r\n                            }\r\n\r\n                            return Clause.Make($\"'{value}'\");\r\n                        }\r\n                    case MemberExpression member:\r\n                        {\r\n                            switch (member.Member)\r\n                            {\r\n                                case PropertyInfo property:\r\n                                    {\r\n                                        if (property.Name == \"Value\" &&\r\n                                            property.DeclaringType != null &&\r\n                                            Nullable.GetUnderlyingType(property.DeclaringType) != null)\r\n                                            return Parse(member.Expression, xRef);\r\n\r\n                                        if (property.Name == \"HasValue\" &&\r\n                                            property.DeclaringType != null &&\r\n                                            Nullable.GetUnderlyingType(property.DeclaringType) != null)\r\n                                        {\r\n                                            return Clause.Make(Parse(member.Expression, xRef), NodeStr[ExpressionType.NotEqual],\r\n                                                Clause.Make(\"''\"));\r\n                                        }\r\n\r\n                                        var colName = property.Name;\r\n                                        var alias = \"\";\r\n                                        if (member.Expression is ParameterExpression paramExpr && xRef.ContainsKey(paramExpr.Name))\r\n                                        {\r\n                                            alias = xRef[paramExpr.Name];\r\n                                        }\r\n\r\n                                        if (member.Type == typeof(bool))\r\n                                            if (isUnary)\r\n                                            {\r\n                                                isUnary = false;\r\n                                                prefix = null;\r\n                                                postfix = null;\r\n                                                continue;\r\n                                            }\r\n                                            else\r\n                                            {\r\n                                                return boolComparison\r\n                                                    ? Clause.Make(!string.IsNullOrEmpty(alias)\r\n                                                        ? $\"[{alias}].[{colName}]\"\r\n                                                        : $\"[{colName}]\")\r\n                                                    : Clause.Make(\r\n                                                        Clause.Make(!string.IsNullOrEmpty(alias)\r\n                                                            ? $\"[{alias}].[{colName}]\"\r\n                                                            : $\"[{colName}]\"), \"=\", Clause.Make(\"1\"));\r\n                                            }\r\n                                        else\r\n                                        {\r\n                                            var value = !string.IsNullOrEmpty(alias)\r\n                                                ? $\"[{alias}].[{colName}]\"\r\n                                                : $\"[{colName}]\";\r\n                                            if (!string.IsNullOrEmpty(prefix))\r\n                                                value = $\"'{prefix}'+{value}\";\r\n                                            if (!string.IsNullOrEmpty(postfix))\r\n                                                value = $\"{value}+'{postfix}'\";\r\n\r\n                                            return Clause.Make(value);\r\n                                        }\r\n                                    }\r\n                                case FieldInfo _:\r\n                                    {\r\n                                        var value = GetValue(member);\r\n                                        if (value is string)\r\n                                        {\r\n                                            value = prefix + (string)value + postfix;\r\n                                        }\r\n\r\n                                        return Clause.Make($\"'{value}'\");\r\n                                    }\r\n                                default:\r\n                                    throw new Exception($\"Expression does not refer to a property or field: {expression}\");\r\n                            }\r\n                        }\r\n                    case MethodCallExpression methodCall:\r\n                        {\r\n                            // LIKE queries:\r\n                            if (methodCall.Method == typeof(string).GetMethod(\"Contains\", new[] { typeof(string) }))\r\n                            {\r\n                                return Clause.Make(Parse(methodCall.Object, xRef), \"LIKE\", Parse(methodCall.Arguments[0], xRef, prefix: \"%\", postfix: \"%\"));\r\n                            }\r\n\r\n                            if (methodCall.Method == typeof(string).GetMethod(\"StartsWith\", new[] { typeof(string) }))\r\n                            {\r\n                                return Clause.Make(Parse(methodCall.Object, xRef), \"LIKE\", Parse(methodCall.Arguments[0], xRef, postfix: \"%\"));\r\n                            }\r\n\r\n                            if (methodCall.Method == typeof(string).GetMethod(\"EndsWith\", new[] { typeof(string) }))\r\n                            {\r\n                                return Clause.Make(Parse(methodCall.Object, xRef), \"LIKE\", Parse(methodCall.Arguments[0], xRef, prefix: \"%\"));\r\n                            }\r\n\r\n                            // IN queries:\r\n                            if (methodCall.Method.Name == \"Contains\")\r\n                            {\r\n                                Expression collection;\r\n                                Expression property;\r\n                                if (methodCall.Method.IsDefined(typeof(ExtensionAttribute)) && methodCall.Arguments.Count == 2)\r\n                                {\r\n                                    collection = methodCall.Arguments[0];\r\n                                    property = methodCall.Arguments[1];\r\n                                }\r\n                                else if (!methodCall.Method.IsDefined(typeof(ExtensionAttribute)) && methodCall.Arguments.Count == 1)\r\n                                {\r\n                                    collection = methodCall.Object;\r\n                                    property = methodCall.Arguments[0];\r\n                                }\r\n                                else\r\n                                {\r\n                                    throw new Exception(\"Unsupported method call: \" + methodCall.Method.Name);\r\n                                }\r\n\r\n                                var sb = new StringBuilder();\r\n                                foreach (var val in (IEnumerable)GetValue(collection))\r\n                                {\r\n                                    sb.Append($\"'{val}',\");\r\n                                }\r\n\r\n                                var values = sb.ToString();\r\n                                values = values.Substring(0, values.Length - 1);\r\n                                return Clause.Make(Parse(property, xRef), \"IN\", Clause.Make($\"({values})\"));\r\n                            }\r\n\r\n                            throw new Exception(\"Unsupported method call: \" + methodCall.Method.Name);\r\n                        }\r\n                    default:\r\n                        throw new Exception(\"Unsupported expression: \" + expression.GetType().Name);\r\n                }\r\n            }\r\n        }\r\n\r\n        private static object GetValue(Expression member)\r\n        {\r\n            try\r\n            {\r\n                var objectMember = Expression.Convert(member, typeof(object));\r\n                var getterLambda = Expression.Lambda<Func<object>>(objectMember);\r\n                var getter = getterLambda.Compile();\r\n                return getter();\r\n            }\r\n            catch { return null; }\r\n        }\r\n\r\n        private class Clause\r\n        {\r\n            public string Sql { get; private set; }\r\n\r\n            public static Clause Make(string sql)\r\n            {\r\n                return new Clause\r\n                {\r\n                    Sql = sql\r\n                };\r\n            }\r\n\r\n            public static Clause Make(string @operator, Clause operand)\r\n            {\r\n                return new Clause\r\n                {\r\n                    Sql = !string.IsNullOrEmpty(@operator) ? $\"({@operator} {operand.Sql})\" : $\"{operand.Sql}\"\r\n                };\r\n            }\r\n\r\n            public static Clause Make(Clause left, string @operator, Clause right)\r\n            {\r\n                return new Clause\r\n                {\r\n                    Sql = $\"({left.Sql} {@operator} {right.Sql})\"\r\n                };\r\n            }\r\n        }\r\n    }\r\n\r\n    #endregion\r\n\r\n    #region OnClause\r\n\r\n    public interface IOnClause<T1, T2>\r\n        where T1 : IBaseModel, new()\r\n        where T2 : IBaseModel, new()\r\n    {\r\n        ICombinedRepository<T1, T2> On(Expression<Func<T1, T2, bool>> expr);\r\n    }\r\n\r\n    public interface IOnClause<T1, T2, T3>\r\n        where T1 : IBaseModel, new()\r\n        where T2 : IBaseModel, new()\r\n        where T3 : IBaseModel, new()\r\n    {\r\n        ICombinedRepository<T1, T2, T3> On(Expression<Func<T1, T2, T3, bool>> expr);\r\n    }\r\n\r\n    public interface IOnClause<T1, T2, T3, T4>\r\n        where T1 : IBaseModel, new()\r\n        where T2 : IBaseModel, new()\r\n        where T3 : IBaseModel, new()\r\n        where T4 : IBaseModel, new()\r\n    {\r\n        ICombinedRepository<T1, T2, T3, T4> On(Expression<Func<T1, T2, T3, T4, bool>> expr);\r\n    }\r\n\r\n    public interface IOnClause<T1, T2, T3, T4, T5>\r\n        where T1 : IBaseModel, new()\r\n        where T2 : IBaseModel, new()\r\n        where T3 : IBaseModel, new()\r\n        where T4 : IBaseModel, new()\r\n        where T5 : IBaseModel, new()\r\n    {\r\n        ICombinedRepository<T1, T2, T3, T4, T5> On(Expression<Func<T1, T2, T3, T4, T5, bool>> expr);\r\n    }\r\n\r\n    public interface IOnClause<T1, T2, T3, T4, T5, T6>\r\n        where T1 : IBaseModel, new()\r\n        where T2 : IBaseModel, new()\r\n        where T3 : IBaseModel, new()\r\n        where T4 : IBaseModel, new()\r\n        where T5 : IBaseModel, new()\r\n        where T6 : IBaseModel, new()\r\n    {\r\n        ICombinedRepository<T1, T2, T3, T4, T5, T6> On(Expression<Func<T1, T2, T3, T4, T5, T6, bool>> expr);\r\n    }\r\n\r\n    public interface IOnClause<T1, T2, T3, T4, T5, T6, T7>\r\n        where T1 : IBaseModel, new()\r\n        where T2 : IBaseModel, new()\r\n        where T3 : IBaseModel, new()\r\n        where T4 : IBaseModel, new()\r\n        where T5 : IBaseModel, new()\r\n        where T6 : IBaseModel, new()\r\n        where T7 : IBaseModel, new()\r\n    {\r\n        ICombinedRepository<T1, T2, T3, T4, T5, T6, T7> On(Expression<Func<T1, T2, T3, T4, T5, T6, T7, bool>> expr);\r\n    }\r\n\r\n    public abstract class BaseOnClause\r\n    {\r\n        protected internal string ConnectionString;\r\n        internal JoinInfo JoinInfo { get; }\r\n\r\n        protected BaseOnClause() : this(new JoinInfo())\r\n        {\r\n        }\r\n\r\n        protected BaseOnClause(JoinInfo previousJoinInfo)\r\n        {\r\n            JoinInfo = previousJoinInfo;\r\n        }\r\n\r\n        protected void AddJoin(Type type, JoinType joinType)\r\n        {\r\n            if (string.IsNullOrEmpty(type.FullName))\r\n                throw new Exception(\"Unsupported Type\");\r\n\r\n            var alias = $\"c{JoinInfo.Joins.Count + 1}\";\r\n            JoinInfo.Joins.Add(new Join(type, joinType, alias));\r\n        }\r\n\r\n        protected void AddExpression(Type type, LambdaExpression expr)\r\n        {\r\n            if (string.IsNullOrEmpty(type.FullName))\r\n                throw new Exception(\"Unsupported Type\");\r\n\r\n            var paramXRef = new Dictionary<string, string>();\r\n            var i = 0;\r\n            foreach (var parameter in expr.Parameters)\r\n            {\r\n                paramXRef.Add(parameter.Name, $\"c{i++}\");\r\n            }\r\n\r\n            JoinInfo.Joins.Last().Expression = expr;\r\n            JoinInfo.Joins.Last().XRef = paramXRef;\r\n        }\r\n    }\r\n\r\n    public class OnClause<T1, T2> : BaseOnClause, IOnClause<T1, T2>\r\n        where T1 : IBaseModel, new()\r\n        where T2 : IBaseModel, new()\r\n    {\r\n        public OnClause(string connectionString, JoinType joinType)\r\n        {\r\n            ConnectionString = connectionString;\r\n            JoinInfo.InitialType = typeof(T1);\r\n            AddJoin(typeof(T2), joinType);\r\n        }\r\n\r\n        public ICombinedRepository<T1, T2> On(Expression<Func<T1, T2, bool>> expr)\r\n        {\r\n            AddExpression(typeof(T2), expr);\r\n            return new CombinedRepository<T1, T2>(this);\r\n        }\r\n    }\r\n\r\n    public class OnClause<T1, T2, T3> : BaseOnClause, IOnClause<T1, T2, T3>\r\n        where T1 : IBaseModel, new()\r\n        where T2 : IBaseModel, new()\r\n        where T3 : IBaseModel, new()\r\n    {\r\n        public OnClause(JoinInfo previousJoinInfo, JoinType joinType) : base(previousJoinInfo)\r\n        {\r\n            AddJoin(typeof(T3), joinType);\r\n        }\r\n\r\n\r\n        public ICombinedRepository<T1, T2, T3> On(Expression<Func<T1, T2, T3, bool>> expr)\r\n        {\r\n            AddExpression(typeof(T3), expr);\r\n            return new CombinedRepository<T1, T2, T3>(this);\r\n        }\r\n    }\r\n\r\n    public class OnClause<T1, T2, T3, T4> : BaseOnClause, IOnClause<T1, T2, T3, T4>\r\n        where T1 : IBaseModel, new()\r\n        where T2 : IBaseModel, new()\r\n        where T3 : IBaseModel, new()\r\n        where T4 : IBaseModel, new()\r\n    {\r\n        public OnClause(JoinInfo previousJoinInfo, JoinType joinType) : base(previousJoinInfo)\r\n        {\r\n            AddJoin(typeof(T4), joinType);\r\n        }\r\n\r\n\r\n        public ICombinedRepository<T1, T2, T3, T4> On(Expression<Func<T1, T2, T3, T4, bool>> expr)\r\n        {\r\n            AddExpression(typeof(T4), expr);\r\n            return new CombinedRepository<T1, T2, T3, T4>(this);\r\n        }\r\n    }\r\n\r\n    public class OnClause<T1, T2, T3, T4, T5> : BaseOnClause, IOnClause<T1, T2, T3, T4, T5>\r\n        where T1 : IBaseModel, new()\r\n        where T2 : IBaseModel, new()\r\n        where T3 : IBaseModel, new()\r\n        where T4 : IBaseModel, new()\r\n        where T5 : IBaseModel, new()\r\n    {\r\n        public OnClause(JoinInfo previousJoinInfo, JoinType joinType) : base(previousJoinInfo)\r\n        {\r\n            AddJoin(typeof(T5), joinType);\r\n        }\r\n\r\n        public ICombinedRepository<T1, T2, T3, T4, T5> On(Expression<Func<T1, T2, T3, T4, T5, bool>> expr)\r\n        {\r\n            AddExpression(typeof(T5), expr);\r\n            return new CombinedRepository<T1, T2, T3, T4, T5>(this);\r\n        }\r\n    }\r\n\r\n\r\n    public class OnClause<T1, T2, T3, T4, T5, T6> : BaseOnClause, IOnClause<T1, T2, T3, T4, T5, T6>\r\n        where T1 : IBaseModel, new()\r\n        where T2 : IBaseModel, new()\r\n        where T3 : IBaseModel, new()\r\n        where T4 : IBaseModel, new()\r\n        where T5 : IBaseModel, new()\r\n        where T6 : IBaseModel, new()\r\n    {\r\n        public OnClause(JoinInfo previousJoinInfo, JoinType joinType) : base(previousJoinInfo)\r\n        {\r\n            AddJoin(typeof(T6), joinType);\r\n        }\r\n\r\n\r\n        public ICombinedRepository<T1, T2, T3, T4, T5, T6> On(Expression<Func<T1, T2, T3, T4, T5, T6, bool>> expr)\r\n        {\r\n            AddExpression(typeof(T6), expr);\r\n            return new CombinedRepository<T1, T2, T3, T4, T5, T6>(this);\r\n        }\r\n    }\r\n\r\n\r\n    public class OnClause<T1, T2, T3, T4, T5, T6, T7> : BaseOnClause, IOnClause<T1, T2, T3, T4, T5, T6, T7>\r\n        where T1 : IBaseModel, new()\r\n        where T2 : IBaseModel, new()\r\n        where T3 : IBaseModel, new()\r\n        where T4 : IBaseModel, new()\r\n        where T5 : IBaseModel, new()\r\n        where T6 : IBaseModel, new()\r\n        where T7 : IBaseModel, new()\r\n    {\r\n        public OnClause(JoinInfo previousJoinInfo, JoinType joinType) : base(previousJoinInfo)\r\n        {\r\n            AddJoin(typeof(T7), joinType);\r\n        }\r\n\r\n\r\n        public ICombinedRepository<T1, T2, T3, T4, T5, T6, T7> On(\r\n            Expression<Func<T1, T2, T3, T4, T5, T6, T7, bool>> expr)\r\n        {\r\n            AddExpression(typeof(T7), expr);\r\n            return new CombinedRepository<T1, T2, T3, T4, T5, T6, T7>(this);\r\n        }\r\n    }\r\n\r\n    #endregion\r\n\r\n    #region JoinInfo\r\n\r\n    public enum JoinType\r\n    {\r\n        Inner,\r\n        Left,\r\n        Right,\r\n        Full\r\n    }\r\n\r\n    public class Join\r\n    {\r\n        public Type ModelType { get; }\r\n        public JoinType JoinType { get; }\r\n        public LambdaExpression Expression { get; set; }\r\n        public string Alias { get; set; }\r\n        public Dictionary<string, string> XRef { get; set; }\r\n\r\n        public Join(Type type, JoinType join, string alias)\r\n        {\r\n            ModelType = type;\r\n            JoinType = join;\r\n            Alias = alias;\r\n        }\r\n\r\n        public string JoinString()\r\n        {\r\n            switch (JoinType)\r\n            {\r\n                case JoinType.Inner:\r\n                    return \"INNER JOIN \";\r\n                case JoinType.Left:\r\n                    return \"LEFT OUTER JOIN \";\r\n                case JoinType.Right:\r\n                    return \"RIGHT OUTER JOIN \";\r\n                case JoinType.Full:\r\n                    return \"FULL OUTER JOIN \";\r\n                default:\r\n                    throw new ArgumentOutOfRangeException();\r\n            }\r\n        }\r\n    }\r\n\r\n    public class JoinInfo\r\n    {\r\n        public Type InitialType { get; set; }\r\n\r\n        /// <summary>\r\n        /// Type: Type of IBaseModel we're joining to\r\n        /// JoinAndExpression the rules for joining to the previous (or initial) model\r\n        /// </summary>\r\n        public List<Join> Joins { get; } = new List<Join>();\r\n    }\r\n\r\n    public interface IJoinable<T1>\r\n        where T1 : IBaseModel, new()\r\n    {\r\n        IOnClause<T1, T2> InnerJoin<T2>() where T2 : IBaseModel, new();\r\n        IOnClause<T1, T2> LeftJoin<T2>() where T2 : IBaseModel, new();\r\n        IOnClause<T1, T2> RightJoin<T2>() where T2 : IBaseModel, new();\r\n        IOnClause<T1, T2> FullJoin<T2>() where T2 : IBaseModel, new();\r\n    }\r\n\r\n    public interface IJoinable<T1, T2>\r\n        where T1 : IBaseModel, new()\r\n        where T2 : IBaseModel, new()\r\n    {\r\n        IOnClause<T1, T2, T3> InnerJoin<T3>() where T3 : IBaseModel, new();\r\n        IOnClause<T1, T2, T3> LeftJoin<T3>() where T3 : IBaseModel, new();\r\n        IOnClause<T1, T2, T3> RightJoin<T3>() where T3 : IBaseModel, new();\r\n        IOnClause<T1, T2, T3> FullJoin<T3>() where T3 : IBaseModel, new();\r\n    }\r\n\r\n    public interface IJoinable<T1, T2, T3>\r\n        where T1 : IBaseModel, new()\r\n        where T2 : IBaseModel, new()\r\n        where T3 : IBaseModel, new()\r\n    {\r\n        IOnClause<T1, T2, T3, T4> InnerJoin<T4>() where T4 : IBaseModel, new();\r\n        IOnClause<T1, T2, T3, T4> LeftJoin<T4>() where T4 : IBaseModel, new();\r\n        IOnClause<T1, T2, T3, T4> RightJoin<T4>() where T4 : IBaseModel, new();\r\n        IOnClause<T1, T2, T3, T4> FullJoin<T4>() where T4 : IBaseModel, new();\r\n    }\r\n\r\n    public interface IJoinable<T1, T2, T3, T4>\r\n        where T1 : IBaseModel, new()\r\n        where T2 : IBaseModel, new()\r\n        where T3 : IBaseModel, new()\r\n        where T4 : IBaseModel, new()\r\n    {\r\n        IOnClause<T1, T2, T3, T4, T5> InnerJoin<T5>() where T5 : IBaseModel, new();\r\n        IOnClause<T1, T2, T3, T4, T5> LeftJoin<T5>() where T5 : IBaseModel, new();\r\n        IOnClause<T1, T2, T3, T4, T5> RightJoin<T5>() where T5 : IBaseModel, new();\r\n        IOnClause<T1, T2, T3, T4, T5> FullJoin<T5>() where T5 : IBaseModel, new();\r\n    }\r\n\r\n    public interface IJoinable<T1, T2, T3, T4, T5>\r\n        where T1 : IBaseModel, new()\r\n        where T2 : IBaseModel, new()\r\n        where T3 : IBaseModel, new()\r\n        where T4 : IBaseModel, new()\r\n        where T5 : IBaseModel, new()\r\n    {\r\n        IOnClause<T1, T2, T3, T4, T5, T6> InnerJoin<T6>() where T6 : IBaseModel, new();\r\n        IOnClause<T1, T2, T3, T4, T5, T6> LeftJoin<T6>() where T6 : IBaseModel, new();\r\n        IOnClause<T1, T2, T3, T4, T5, T6> RightJoin<T6>() where T6 : IBaseModel, new();\r\n        IOnClause<T1, T2, T3, T4, T5, T6> FullJoin<T6>() where T6 : IBaseModel, new();\r\n    }\r\n\r\n    public interface IJoinable<T1, T2, T3, T4, T5, T6>\r\n        where T1 : IBaseModel, new()\r\n        where T2 : IBaseModel, new()\r\n        where T3 : IBaseModel, new()\r\n        where T4 : IBaseModel, new()\r\n        where T5 : IBaseModel, new()\r\n        where T6 : IBaseModel, new()\r\n    {\r\n        IOnClause<T1, T2, T3, T4, T5, T6, T7> InnerJoin<T7>() where T7 : IBaseModel, new();\r\n        IOnClause<T1, T2, T3, T4, T5, T6, T7> LeftJoin<T7>() where T7 : IBaseModel, new();\r\n        IOnClause<T1, T2, T3, T4, T5, T6, T7> RightJoin<T7>() where T7 : IBaseModel, new();\r\n        IOnClause<T1, T2, T3, T4, T5, T6, T7> FullJoin<T7>() where T7 : IBaseModel, new();\r\n    }\r\n\r\n    #endregion\r\n\r\n    #region CombinedRepository\r\n\r\n    public interface ICombinedRepository\r\n    {\r\n        JoinInfo JoinInfo { get; }\r\n    }\r\n\r\n    public interface ICombinedRepository<T1, T2> : IJoinable<T1, T2>, ICombinedRepository\r\n        where T1 : IBaseModel, new()\r\n        where T2 : IBaseModel, new()\r\n    {\r\n        IEnumerable<Tuple<T1, T2>> Results();\r\n        IEnumerable<Tuple<T1, T2>> Where(Expression<Func<T1, T2, bool>> clause);\r\n    }\r\n\r\n    public interface ICombinedRepository<T1, T2, T3> : IJoinable<T1, T2, T3>, ICombinedRepository\r\n        where T1 : IBaseModel, new()\r\n        where T2 : IBaseModel, new()\r\n        where T3 : IBaseModel, new()\r\n    {\r\n        IEnumerable<Tuple<T1, T2, T3>> Results();\r\n        IEnumerable<Tuple<T1, T2, T3>> Where(Expression<Func<T1, T2, T3, bool>> clause);\r\n    }\r\n\r\n\r\n    public interface ICombinedRepository<T1, T2, T3, T4> : IJoinable<T1, T2, T3, T4>, ICombinedRepository\r\n        where T1 : IBaseModel, new()\r\n        where T2 : IBaseModel, new()\r\n        where T3 : IBaseModel, new()\r\n        where T4 : IBaseModel, new()\r\n    {\r\n        IEnumerable<Tuple<T1, T2, T3, T4>> Results();\r\n        IEnumerable<Tuple<T1, T2, T3, T4>> Where(Expression<Func<T1, T2, T3, T4, bool>> clause);\r\n    }\r\n\r\n    public interface ICombinedRepository<T1, T2, T3, T4, T5> : IJoinable<T1, T2, T3, T4, T5>, ICombinedRepository\r\n        where T1 : IBaseModel, new()\r\n        where T2 : IBaseModel, new()\r\n        where T3 : IBaseModel, new()\r\n        where T4 : IBaseModel, new()\r\n        where T5 : IBaseModel, new()\r\n    {\r\n        IEnumerable<Tuple<T1, T2, T3, T4, T5>> Results();\r\n        IEnumerable<Tuple<T1, T2, T3, T4, T5>> Where(Expression<Func<T1, T2, T3, T4, T5, bool>> clause);\r\n    }\r\n\r\n    public interface ICombinedRepository<T1, T2, T3, T4, T5, T6> : IJoinable<T1, T2, T3, T4, T5, T6>, ICombinedRepository\r\n        where T1 : IBaseModel, new()\r\n        where T2 : IBaseModel, new()\r\n        where T3 : IBaseModel, new()\r\n        where T4 : IBaseModel, new()\r\n        where T5 : IBaseModel, new()\r\n        where T6 : IBaseModel, new()\r\n    {\r\n        IEnumerable<Tuple<T1, T2, T3, T4, T5, T6>> Results();\r\n        IEnumerable<Tuple<T1, T2, T3, T4, T5, T6>> Where(Expression<Func<T1, T2, T3, T4, T5, T6, bool>> clause);\r\n    }\r\n\r\n    public interface ICombinedRepository<T1, T2, T3, T4, T5, T6, T7> : ICombinedRepository\r\n        where T1 : IBaseModel, new()\r\n        where T2 : IBaseModel, new()\r\n        where T3 : IBaseModel, new()\r\n        where T4 : IBaseModel, new()\r\n        where T5 : IBaseModel, new()\r\n        where T6 : IBaseModel, new()\r\n        where T7 : IBaseModel, new()\r\n    {\r\n        IEnumerable<Tuple<T1, T2, T3, T4, T5, T6, T7>> Results();\r\n        IEnumerable<Tuple<T1, T2, T3, T4, T5, T6, T7>> Where(Expression<Func<T1, T2, T3, T4, T5, T6, T7, bool>> clause);\r\n    }\r\n\r\n    public abstract class CombinedRepositoryBase : RepositoryDataAccess, ICombinedRepository\r\n    {\r\n        protected const string SqlParamSeparator = \"__\";\r\n\r\n        public JoinInfo JoinInfo { get; }\r\n        public string WhereClause { get; set; }\r\n\r\n        protected CombinedRepositoryBase(BaseOnClause previousOnClause) : base(previousOnClause.ConnectionString)\r\n        {\r\n            JoinInfo = previousOnClause.JoinInfo;\r\n        }\r\n\r\n        private string GenerateQuery()\r\n        {\r\n            var sql = $\"SELECT \";\r\n            if (!(Activator.CreateInstance(JoinInfo.InitialType) is IBaseModel iInst))\r\n                throw new Exception($\"Initial Type wasn't an IBaseModel, but was {JoinInfo.InitialType}\");\r\n\r\n            var prop = JoinInfo.InitialType.GetProperty(\"Columns\", BindingFlags.Static | BindingFlags.Public);\r\n            if (prop == null)\r\n                throw new Exception(\r\n                    $\"internal static Columns property could not be found on {JoinInfo.InitialType.FullName}\");\r\n\r\n            if (!(prop.GetValue(iInst) is List<ColumnDefinition> iCols))\r\n                throw new Exception(\r\n                    $\"internal static Columns property is not of type List<ColumnDefinition> on {JoinInfo.InitialType.FullName}\");\r\n\r\n            foreach (var column in iCols)\r\n            {\r\n                sql += $\"[c0].[{column.ColumnName}] AS '{iInst.EntityName}{SqlParamSeparator}{column.ColumnName}', \";\r\n            }\r\n\r\n\r\n            foreach (var @join in JoinInfo.Joins)\r\n            {\r\n                if (!(Activator.CreateInstance(@join.ModelType) is IBaseModel tInst))\r\n                    throw new Exception($\"Join Type wasn't an IBaseModel, but was {@join.ModelType}\");\r\n\r\n                prop = @join.ModelType.GetProperty(\"Columns\", BindingFlags.Static | BindingFlags.Public);\r\n                if (prop == null)\r\n                    throw new Exception(\r\n                        $\"internal static Columns property could not be found on {@join.ModelType.FullName}\");\r\n\r\n                if (!(prop.GetValue(tInst) is List<ColumnDefinition> tCols))\r\n                    throw new Exception(\r\n                        $\"internal static Columns property is not of type List<ColumnDefinition> on {@join.ModelType.FullName}\");\r\n\r\n                foreach (var column in tCols)\r\n                {\r\n                    sql +=\r\n                        $\"[{@join.Alias}].[{column.ColumnName}] AS '{tInst.EntityName}{SqlParamSeparator}{column.ColumnName}', \";\r\n                }\r\n            }\r\n\r\n            sql = sql.Substring(0, sql.Length - 2);\r\n\r\n            sql += $\" FROM [{iInst.EntityName}] c0 \";\r\n\r\n            foreach (var @join in JoinInfo.Joins)\r\n            {\r\n                if (!(Activator.CreateInstance(@join.ModelType) is IBaseModel tInst))\r\n                    throw new Exception($\"Join Type wasn't an IBaseModel, but was {@join.ModelType}\");\r\n\r\n                var expressionSql = ExpressionParser.ToSql(@join.Expression, @join.XRef);\r\n                sql += $\" {@join.JoinString()} [{tInst.EntityName}] {@join.Alias} ON {expressionSql}\";\r\n            }\r\n\r\n            if (!string.IsNullOrWhiteSpace(WhereClause))\r\n            {\r\n                sql += $\" WHERE {WhereClause}\";\r\n            }\r\n\r\n            return sql;\r\n        }\r\n\r\n        protected DataTable BaseResults()\r\n        {\r\n            var query = GenerateQuery();\r\n            DataTable dt;\r\n\r\n            using (var cn = new SqlConnection(ConnectionString))\r\n            {\r\n                using (var cmd = CreateCommand(cn, query))\r\n                {\r\n                    if (HasInjection(cmd.CommandText))\r\n                        throw new Exception(\"Sql Injection attempted. Aborted\");\r\n\r\n                    //Execute\r\n                    cn.Open();\r\n                    dt = ToDataTable(cmd);\r\n                    if (dt == null)\r\n                        return null;\r\n\r\n                    cn.Close();\r\n                }\r\n            }\r\n\r\n            return dt;\r\n        }\r\n    }\r\n\r\n    public class CombinedRepository<T1, T2> : CombinedRepositoryBase, ICombinedRepository<T1, T2>\r\n        where T1 : IBaseModel, new()\r\n        where T2 : IBaseModel, new()\r\n    {\r\n        public CombinedRepository(BaseOnClause previousOnClause) : base(previousOnClause)\r\n        {\r\n        }\r\n\r\n        public IOnClause<T1, T2, T3> InnerJoin<T3>() where T3 : IBaseModel, new()\r\n        {\r\n            return Join<T3>(JoinType.Inner);\r\n        }\r\n\r\n        public IOnClause<T1, T2, T3> LeftJoin<T3>() where T3 : IBaseModel, new()\r\n        {\r\n            return Join<T3>(JoinType.Left);\r\n        }\r\n\r\n        public IOnClause<T1, T2, T3> RightJoin<T3>() where T3 : IBaseModel, new()\r\n        {\r\n            return Join<T3>(JoinType.Right);\r\n        }\r\n\r\n        public IOnClause<T1, T2, T3> FullJoin<T3>() where T3 : IBaseModel, new()\r\n        {\r\n            return Join<T3>(JoinType.Full);\r\n        }\r\n\r\n        private IOnClause<T1, T2, T3> Join<T3>(JoinType joinType) where T3 : IBaseModel, new()\r\n        {\r\n            var onClause = new OnClause<T1, T2, T3>(JoinInfo, joinType) { ConnectionString = ConnectionString };\r\n            return onClause;\r\n        }\r\n\r\n        public IEnumerable<Tuple<T1, T2>> Results()\r\n        {\r\n            var dt = BaseResults();\r\n\r\n            return EnumerateDataTable(dt);\r\n        }\r\n\r\n        public IEnumerable<Tuple<T1, T2>> Where(Expression<Func<T1, T2, bool>> clause)\r\n        {\r\n            WhereClause = ExpressionParser.ToSql(clause, JoinInfo.Joins.Last().XRef);\r\n\r\n            var dt = BaseResults();\r\n\r\n            return EnumerateDataTable(dt);\r\n        }\r\n\r\n        private IEnumerable<Tuple<T1, T2>> EnumerateDataTable(DataTable dt)\r\n        {\r\n            foreach (DataRow row in dt.Rows)\r\n            {\r\n                var t1Inst = new T1();\r\n                var t2Inst = new T2();\r\n\r\n                var tuple = new Tuple<T1, T2>(\r\n                    (T1)t1Inst.SetValues(row, $\"{t1Inst.EntityName}{SqlParamSeparator}\"),\r\n                    (T2)t2Inst.SetValues(row, $\"{t2Inst.EntityName}{SqlParamSeparator}\"));\r\n\r\n                yield return tuple;\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    public class CombinedRepository<T1, T2, T3> : CombinedRepositoryBase, ICombinedRepository<T1, T2, T3>\r\n        where T1 : IBaseModel, new()\r\n        where T2 : IBaseModel, new()\r\n        where T3 : IBaseModel, new()\r\n    {\r\n        public CombinedRepository(BaseOnClause previousOnClause) : base(previousOnClause)\r\n        {\r\n        }\r\n\r\n        public IOnClause<T1, T2, T3, T4> InnerJoin<T4>() where T4 : IBaseModel, new()\r\n        {\r\n            return Join<T4>(JoinType.Inner);\r\n        }\r\n\r\n        public IOnClause<T1, T2, T3, T4> LeftJoin<T4>() where T4 : IBaseModel, new()\r\n        {\r\n            return Join<T4>(JoinType.Left);\r\n        }\r\n\r\n        public IOnClause<T1, T2, T3, T4> RightJoin<T4>() where T4 : IBaseModel, new()\r\n        {\r\n            return Join<T4>(JoinType.Right);\r\n        }\r\n\r\n        public IOnClause<T1, T2, T3, T4> FullJoin<T4>() where T4 : IBaseModel, new()\r\n        {\r\n            return Join<T4>(JoinType.Full);\r\n        }\r\n\r\n        private IOnClause<T1, T2, T3, T4> Join<T4>(JoinType joinType) where T4 : IBaseModel, new()\r\n        {\r\n            var onClause = new OnClause<T1, T2, T3, T4>(JoinInfo, joinType) { ConnectionString = ConnectionString };\r\n            return onClause;\r\n        }\r\n\r\n        public IEnumerable<Tuple<T1, T2, T3>> Results()\r\n        {\r\n            var dt = BaseResults();\r\n\r\n            return EnumerateDataTable(dt);\r\n        }\r\n\r\n        public IEnumerable<Tuple<T1, T2, T3>> Where(Expression<Func<T1, T2, T3, bool>> clause)\r\n        {\r\n            WhereClause = ExpressionParser.ToSql(clause, JoinInfo.Joins.Last().XRef);\r\n\r\n            var dt = BaseResults();\r\n\r\n            return EnumerateDataTable(dt);\r\n        }\r\n\r\n        private IEnumerable<Tuple<T1, T2, T3>> EnumerateDataTable(DataTable dt)\r\n        {\r\n            foreach (DataRow row in dt.Rows)\r\n            {\r\n                var t1Inst = new T1();\r\n                var t2Inst = new T2();\r\n                var t3Inst = new T3();\r\n\r\n                var tuple = new Tuple<T1, T2, T3>(\r\n                    (T1)t1Inst.SetValues(row, $\"{t1Inst.EntityName}{SqlParamSeparator}\"),\r\n                    (T2)t2Inst.SetValues(row, $\"{t2Inst.EntityName}{SqlParamSeparator}\"),\r\n                    (T3)t3Inst.SetValues(row, $\"{t3Inst.EntityName}{SqlParamSeparator}\"));\r\n\r\n                yield return tuple;\r\n            }\r\n        }\r\n    }\r\n\r\n    public class CombinedRepository<T1, T2, T3, T4> : CombinedRepositoryBase, ICombinedRepository<T1, T2, T3, T4>\r\n        where T1 : IBaseModel, new()\r\n        where T2 : IBaseModel, new()\r\n        where T3 : IBaseModel, new()\r\n        where T4 : IBaseModel, new()\r\n    {\r\n        public CombinedRepository(BaseOnClause previousOnClause) : base(previousOnClause)\r\n        {\r\n        }\r\n\r\n        public IOnClause<T1, T2, T3, T4, T5> InnerJoin<T5>() where T5 : IBaseModel, new()\r\n        {\r\n            return Join<T5>(JoinType.Inner);\r\n        }\r\n\r\n        public IOnClause<T1, T2, T3, T4, T5> LeftJoin<T5>() where T5 : IBaseModel, new()\r\n        {\r\n            return Join<T5>(JoinType.Left);\r\n        }\r\n\r\n        public IOnClause<T1, T2, T3, T4, T5> RightJoin<T5>() where T5 : IBaseModel, new()\r\n        {\r\n            return Join<T5>(JoinType.Right);\r\n        }\r\n\r\n        public IOnClause<T1, T2, T3, T4, T5> FullJoin<T5>() where T5 : IBaseModel, new()\r\n        {\r\n            return Join<T5>(JoinType.Full);\r\n        }\r\n\r\n        private IOnClause<T1, T2, T3, T4, T5> Join<T5>(JoinType joinType) where T5 : IBaseModel, new()\r\n        {\r\n            var onClause = new OnClause<T1, T2, T3, T4, T5>(JoinInfo, joinType)\r\n            {\r\n                ConnectionString = ConnectionString\r\n            };\r\n            return onClause;\r\n        }\r\n\r\n        public IEnumerable<Tuple<T1, T2, T3, T4>> Results()\r\n        {\r\n            var dt = BaseResults();\r\n\r\n            return EnumerateDataTable(dt);\r\n        }\r\n\r\n        public IEnumerable<Tuple<T1, T2, T3, T4>> Where(Expression<Func<T1, T2, T3, T4, bool>> clause)\r\n        {\r\n            WhereClause = ExpressionParser.ToSql(clause, JoinInfo.Joins.Last().XRef);\r\n\r\n            var dt = BaseResults();\r\n\r\n            return EnumerateDataTable(dt);\r\n        }\r\n\r\n        private IEnumerable<Tuple<T1, T2, T3, T4>> EnumerateDataTable(DataTable dt)\r\n        {\r\n            foreach (DataRow row in dt.Rows)\r\n            {\r\n                var t1Inst = new T1();\r\n                var t2Inst = new T2();\r\n                var t3Inst = new T3();\r\n                var t4Inst = new T4();\r\n\r\n                var tuple = new Tuple<T1, T2, T3, T4>(\r\n                    (T1)t1Inst.SetValues(row, $\"{t1Inst.EntityName}{SqlParamSeparator}\"),\r\n                    (T2)t2Inst.SetValues(row, $\"{t2Inst.EntityName}{SqlParamSeparator}\"),\r\n                    (T3)t3Inst.SetValues(row, $\"{t3Inst.EntityName}{SqlParamSeparator}\"),\r\n                    (T4)t4Inst.SetValues(row, $\"{t4Inst.EntityName}{SqlParamSeparator}\"));\r\n\r\n                yield return tuple;\r\n            }\r\n        }\r\n    }\r\n\r\n    public class CombinedRepository<T1, T2, T3, T4, T5> : CombinedRepositoryBase,\r\n        ICombinedRepository<T1, T2, T3, T4, T5>\r\n        where T1 : IBaseModel, new()\r\n        where T2 : IBaseModel, new()\r\n        where T3 : IBaseModel, new()\r\n        where T4 : IBaseModel, new()\r\n        where T5 : IBaseModel, new()\r\n    {\r\n        public CombinedRepository(BaseOnClause previousOnClause) : base(previousOnClause)\r\n        {\r\n        }\r\n\r\n        public IOnClause<T1, T2, T3, T4, T5, T6> InnerJoin<T6>() where T6 : IBaseModel, new()\r\n        {\r\n            return Join<T6>(JoinType.Inner);\r\n        }\r\n\r\n        public IOnClause<T1, T2, T3, T4, T5, T6> LeftJoin<T6>() where T6 : IBaseModel, new()\r\n        {\r\n            return Join<T6>(JoinType.Left);\r\n        }\r\n\r\n        public IOnClause<T1, T2, T3, T4, T5, T6> RightJoin<T6>() where T6 : IBaseModel, new()\r\n        {\r\n            return Join<T6>(JoinType.Right);\r\n        }\r\n\r\n        public IOnClause<T1, T2, T3, T4, T5, T6> FullJoin<T6>() where T6 : IBaseModel, new()\r\n        {\r\n            return Join<T6>(JoinType.Full);\r\n        }\r\n\r\n        private IOnClause<T1, T2, T3, T4, T5, T6> Join<T6>(JoinType joinType) where T6 : IBaseModel, new()\r\n        {\r\n            var onClause = new OnClause<T1, T2, T3, T4, T5, T6>(JoinInfo, joinType)\r\n            {\r\n                ConnectionString = ConnectionString\r\n            };\r\n            return onClause;\r\n        }\r\n\r\n        public IEnumerable<Tuple<T1, T2, T3, T4, T5>> Results()\r\n        {\r\n            var dt = BaseResults();\r\n\r\n            return EnumerateDataTable(dt);\r\n        }\r\n\r\n        public IEnumerable<Tuple<T1, T2, T3, T4, T5>> Where(Expression<Func<T1, T2, T3, T4, T5, bool>> clause)\r\n        {\r\n            WhereClause = ExpressionParser.ToSql(clause, JoinInfo.Joins.Last().XRef);\r\n\r\n            var dt = BaseResults();\r\n\r\n            return EnumerateDataTable(dt);\r\n        }\r\n\r\n        private IEnumerable<Tuple<T1, T2, T3, T4, T5>> EnumerateDataTable(DataTable dt)\r\n        {\r\n            foreach (DataRow row in dt.Rows)\r\n            {\r\n                var t1Inst = new T1();\r\n                var t2Inst = new T2();\r\n                var t3Inst = new T3();\r\n                var t4Inst = new T4();\r\n                var t5Inst = new T5();\r\n\r\n                var tuple = new Tuple<T1, T2, T3, T4, T5>(\r\n                    (T1)t1Inst.SetValues(row, $\"{t1Inst.EntityName}{SqlParamSeparator}\"),\r\n                    (T2)t2Inst.SetValues(row, $\"{t2Inst.EntityName}{SqlParamSeparator}\"),\r\n                    (T3)t3Inst.SetValues(row, $\"{t3Inst.EntityName}{SqlParamSeparator}\"),\r\n                    (T4)t4Inst.SetValues(row, $\"{t4Inst.EntityName}{SqlParamSeparator}\"),\r\n                    (T5)t5Inst.SetValues(row, $\"{t5Inst.EntityName}{SqlParamSeparator}\"));\r\n\r\n                yield return tuple;\r\n            }\r\n        }\r\n    }\r\n\r\n    public class CombinedRepository<T1, T2, T3, T4, T5, T6> : CombinedRepositoryBase,\r\n        ICombinedRepository<T1, T2, T3, T4, T5, T6>\r\n        where T1 : IBaseModel, new()\r\n        where T2 : IBaseModel, new()\r\n        where T3 : IBaseModel, new()\r\n        where T4 : IBaseModel, new()\r\n        where T5 : IBaseModel, new()\r\n        where T6 : IBaseModel, new()\r\n    {\r\n        public CombinedRepository(BaseOnClause previousOnClause) : base(previousOnClause)\r\n        {\r\n        }\r\n\r\n        public IOnClause<T1, T2, T3, T4, T5, T6, T7> InnerJoin<T7>() where T7 : IBaseModel, new()\r\n        {\r\n            return Join<T7>(JoinType.Inner);\r\n        }\r\n\r\n        public IOnClause<T1, T2, T3, T4, T5, T6, T7> LeftJoin<T7>() where T7 : IBaseModel, new()\r\n        {\r\n            return Join<T7>(JoinType.Left);\r\n        }\r\n\r\n        public IOnClause<T1, T2, T3, T4, T5, T6, T7> RightJoin<T7>() where T7 : IBaseModel, new()\r\n        {\r\n            return Join<T7>(JoinType.Right);\r\n        }\r\n\r\n        public IOnClause<T1, T2, T3, T4, T5, T6, T7> FullJoin<T7>() where T7 : IBaseModel, new()\r\n        {\r\n            return Join<T7>(JoinType.Full);\r\n        }\r\n\r\n        private IOnClause<T1, T2, T3, T4, T5, T6, T7> Join<T7>(JoinType joinType) where T7 : IBaseModel, new()\r\n        {\r\n            var onClause = new OnClause<T1, T2, T3, T4, T5, T6, T7>(JoinInfo, joinType)\r\n            {\r\n                ConnectionString = ConnectionString\r\n            };\r\n            return onClause;\r\n        }\r\n\r\n        public IEnumerable<Tuple<T1, T2, T3, T4, T5, T6>> Results()\r\n        {\r\n            var dt = BaseResults();\r\n\r\n            return EnumerateDataTable(dt);\r\n        }\r\n\r\n        public IEnumerable<Tuple<T1, T2, T3, T4, T5, T6>> Where(Expression<Func<T1, T2, T3, T4, T5, T6, bool>> clause)\r\n        {\r\n            WhereClause = ExpressionParser.ToSql(clause, JoinInfo.Joins.Last().XRef);\r\n\r\n            var dt = BaseResults();\r\n\r\n            return EnumerateDataTable(dt);\r\n        }\r\n\r\n        private IEnumerable<Tuple<T1, T2, T3, T4, T5, T6>> EnumerateDataTable(DataTable dt)\r\n        {\r\n            foreach (DataRow row in dt.Rows)\r\n            {\r\n                var t1Inst = new T1();\r\n                var t2Inst = new T2();\r\n                var t3Inst = new T3();\r\n                var t4Inst = new T4();\r\n                var t5Inst = new T5();\r\n                var t6Inst = new T6();\r\n\r\n                var tuple = new Tuple<T1, T2, T3, T4, T5, T6>(\r\n                    (T1)t1Inst.SetValues(row, $\"{t1Inst.EntityName}{SqlParamSeparator}\"),\r\n                    (T2)t2Inst.SetValues(row, $\"{t2Inst.EntityName}{SqlParamSeparator}\"),\r\n                    (T3)t3Inst.SetValues(row, $\"{t3Inst.EntityName}{SqlParamSeparator}\"),\r\n                    (T4)t4Inst.SetValues(row, $\"{t4Inst.EntityName}{SqlParamSeparator}\"),\r\n                    (T5)t5Inst.SetValues(row, $\"{t5Inst.EntityName}{SqlParamSeparator}\"),\r\n                    (T6)t6Inst.SetValues(row, $\"{t6Inst.EntityName}{SqlParamSeparator}\"));\r\n\r\n                yield return tuple;\r\n            }\r\n        }\r\n    }\r\n\r\n    public class CombinedRepository<T1, T2, T3, T4, T5, T6, T7> : CombinedRepositoryBase,\r\n        ICombinedRepository<T1, T2, T3, T4, T5, T6, T7>\r\n        where T1 : IBaseModel, new()\r\n        where T2 : IBaseModel, new()\r\n        where T3 : IBaseModel, new()\r\n        where T4 : IBaseModel, new()\r\n        where T5 : IBaseModel, new()\r\n        where T6 : IBaseModel, new()\r\n        where T7 : IBaseModel, new()\r\n    {\r\n        public CombinedRepository(BaseOnClause previousOnClause) : base(previousOnClause)\r\n        {\r\n        }\r\n\r\n        public IEnumerable<Tuple<T1, T2, T3, T4, T5, T6, T7>> Results()\r\n        {\r\n            var dt = BaseResults();\r\n\r\n            return EnumerateDataTable(dt);\r\n        }\r\n\r\n        public IEnumerable<Tuple<T1, T2, T3, T4, T5, T6, T7>> Where(Expression<Func<T1, T2, T3, T4, T5, T6, T7, bool>> clause)\r\n        {\r\n            WhereClause = ExpressionParser.ToSql(clause, JoinInfo.Joins.Last().XRef);\r\n\r\n            var dt = BaseResults();\r\n\r\n            return EnumerateDataTable(dt);\r\n        }\r\n\r\n        private IEnumerable<Tuple<T1, T2, T3, T4, T5, T6, T7>> EnumerateDataTable(DataTable dt)\r\n        {\r\n            foreach (DataRow row in dt.Rows)\r\n            {\r\n                var t1Inst = new T1();\r\n                var t2Inst = new T2();\r\n                var t3Inst = new T3();\r\n                var t4Inst = new T4();\r\n                var t5Inst = new T5();\r\n                var t6Inst = new T6();\r\n                var t7Inst = new T7();\r\n\r\n                var tuple = new Tuple<T1, T2, T3, T4, T5, T6, T7>(\r\n                    (T1)t1Inst.SetValues(row, $\"{t1Inst.EntityName}{SqlParamSeparator}\"),\r\n                    (T2)t2Inst.SetValues(row, $\"{t2Inst.EntityName}{SqlParamSeparator}\"),\r\n                    (T3)t3Inst.SetValues(row, $\"{t3Inst.EntityName}{SqlParamSeparator}\"),\r\n                    (T4)t4Inst.SetValues(row, $\"{t4Inst.EntityName}{SqlParamSeparator}\"),\r\n                    (T5)t5Inst.SetValues(row, $\"{t5Inst.EntityName}{SqlParamSeparator}\"),\r\n                    (T6)t6Inst.SetValues(row, $\"{t6Inst.EntityName}{SqlParamSeparator}\"),\r\n                    (T7)t7Inst.SetValues(row, $\"{t7Inst.EntityName}{SqlParamSeparator}\"));\r\n\r\n                yield return tuple;\r\n            }\r\n        }\r\n    }\r\n\r\n    #endregion\r\n\r\n    public abstract class RepositoryDataAccess\r\n    {\r\n        protected Action<Exception> Logger;\r\n        protected string ConnectionString;\r\n\r\n        protected RepositoryDataAccess(string connectionString)\r\n        {\r\n            Logger = exception => { };\r\n            ConnectionString = connectionString;\r\n        }\r\n\r\n        protected SqlCommand CreateCommand(SqlConnection cn, string command)\r\n        {\r\n            var cmd = new SqlCommand\r\n            {\r\n                Connection = cn,\r\n                CommandType = CommandType.Text,\r\n                CommandText = command\r\n            };\r\n            return cmd;\r\n        }\r\n\r\n        protected bool HasInjection(string query)\r\n        {\r\n            var isSqlInjection = false;\r\n\r\n            string[] sqlCheckList =\r\n            {\r\n                \"--\", \";--\", \"/*\", \"*/\"\r\n            };\r\n\r\n            var checkString = query.Replace(\"'\", \"''\");\r\n\r\n            for (var i = 0; i <= sqlCheckList.Length - 1; i++)\r\n            {\r\n                if ((checkString.IndexOf(sqlCheckList[i], StringComparison.OrdinalIgnoreCase) < 0))\r\n                    continue;\r\n                isSqlInjection = true;\r\n                break;\r\n            }\r\n\r\n            return isSqlInjection;\r\n        }\r\n\r\n        protected bool ToDataTable(SqlCommand cmd, SqlConnection cn, out DataTable dt)\r\n        {\r\n            var isSuccess = true;\r\n            if (HasInjection(cmd.CommandText))\r\n                throw new Exception(\"Sql Injection attempted. Aborted\");\r\n\r\n            //Execute\r\n            cn.Open();\r\n            dt = ToDataTable(cmd);\r\n            cn.Close();\r\n\r\n            if (dt == null)\r\n                isSuccess = false;\r\n            return isSuccess;\r\n        }\r\n\r\n        protected DataTable ToDataTable(SqlCommand cmd)\r\n        {\r\n            try\r\n            {\r\n                var da = new SqlDataAdapter(cmd);\r\n                var dt = new DataTable();\r\n                da.Fill(dt);\r\n                return dt;\r\n            }\r\n            catch (Exception ex)\r\n            {\r\n                Logger(ex);\r\n                return null;\r\n            }\r\n        }\r\n    }\r\n\r\n");
            
            #line 1702 "C:\Users\Jimmy\source\repos\RepoLite\src\RepoLite\RepoLite.GeneratorEngine\Generators\CSharp\SQLServer\Templates\BaseRepository.tt"
 if (generationSettings.IncludeCaching) { 
            
            #line default
            #line hidden
            this.Write("    internal static class CacheHelper\r\n    {\r\n        private static int _cacheDuration;\r\n\r\n        public static void Initialize(int cacheDuration)\r\n        {\r\n            _cacheDuration = cacheDuration;\r\n        }\r\n\r\n        public static void SaveToCache<TC>(string cacheKey, TC savedItem)\r\n            where TC : BaseModel\r\n        {\r\n            RemoveFromCache(cacheKey);\r\n            MemoryCache.Default.Add(cacheKey, savedItem, DateTimeOffset.Now.AddSeconds(_cacheDuration));\r\n\r\n        }\r\n\r\n        public static TC GetFromCache<TC>(string cacheKey)\r\n            where TC : BaseModel\r\n        {\r\n            var cacheItem = MemoryCache.Default[cacheKey] as TC;\r\n\r\n            return cacheItem;\r\n        }\r\n\r\n        public static void RemoveFromCache(string cacheKey)\r\n        {\r\n            if (IsInCache(cacheKey))\r\n            {\r\n                MemoryCache.Default.Remove(cacheKey);\r\n            }\r\n        }\r\n\r\n        public static bool IsInCache(string cacheKey)\r\n        {\r\n            return MemoryCache.Default[cacheKey] != null;\r\n        }\r\n    }\r\n");
            
            #line 1741 "C:\Users\Jimmy\source\repos\RepoLite\src\RepoLite\RepoLite.GeneratorEngine\Generators\CSharp\SQLServer\Templates\BaseRepository.tt"
 } 
            
            #line default
            #line hidden
            this.Write("\r\n    public abstract partial class BaseRepository<T> : RepositoryDataAccess, IBaseRepository<T>\r\n        where T : IBaseModel, new()\r\n    {\r\n\r\n        private List<ColumnDefinition> Columns;\r\n\r\n        protected readonly string Schema;\r\n        protected readonly string TableName;\r\n");
            
            #line 1751 "C:\Users\Jimmy\source\repos\RepoLite\src\RepoLite\RepoLite.GeneratorEngine\Generators\CSharp\SQLServer\Templates\BaseRepository.tt"
 if (generationSettings.IncludeCaching) { 
            
            #line default
            #line hidden
            this.Write("        protected bool CacheEnabled;\r\n        protected int CacheDuration;\r\n");
            
            #line 1754 "C:\Users\Jimmy\source\repos\RepoLite\src\RepoLite\RepoLite.GeneratorEngine\Generators\CSharp\SQLServer\Templates\BaseRepository.tt"
 } 
            
            #line default
            #line hidden
            
            #line 1755 "C:\Users\Jimmy\source\repos\RepoLite\src\RepoLite\RepoLite.GeneratorEngine\Generators\CSharp\SQLServer\Templates\BaseRepository.tt"
 if (generationSettings.IncludeCaching) { 
            
            #line default
            #line hidden
            this.Write("        protected BaseRepository(string connectionString, Action<Exception> logMethod, string schema, string table, List<ColumnDefinition> columns, bool enableCache, int cacheDurationInSeconds) : base(connectionString)\r\n");
            
            #line 1757 "C:\Users\Jimmy\source\repos\RepoLite\src\RepoLite\RepoLite.GeneratorEngine\Generators\CSharp\SQLServer\Templates\BaseRepository.tt"
 } 
            
            #line default
            #line hidden
            
            #line 1758 "C:\Users\Jimmy\source\repos\RepoLite\src\RepoLite\RepoLite.GeneratorEngine\Generators\CSharp\SQLServer\Templates\BaseRepository.tt"
 if (!generationSettings.IncludeCaching) { 
            
            #line default
            #line hidden
            this.Write("        protected BaseRepository(string connectionString, Action<Exception> logMethod, string schema, string table, List<ColumnDefinition> columns) : base(connectionString)\r\n");
            
            #line 1760 "C:\Users\Jimmy\source\repos\RepoLite\src\RepoLite\RepoLite.GeneratorEngine\Generators\CSharp\SQLServer\Templates\BaseRepository.tt"
 } 
            
            #line default
            #line hidden
            this.Write("        {\r\n            Schema = schema;\r\n            TableName = table;\r\n            Logger = logMethod ?? (exception => { });\r\n            Columns = columns;\r\n\r\n");
            
            #line 1767 "C:\Users\Jimmy\source\repos\RepoLite\src\RepoLite\RepoLite.GeneratorEngine\Generators\CSharp\SQLServer\Templates\BaseRepository.tt"
 if (generationSettings.IncludeCaching) { 
            
            #line default
            #line hidden
            this.Write("            if (enableCache)\r\n            {\r\n                EnableCache(cacheDurationInSeconds);\r\n            }\r\n");
            
            #line 1772 "C:\Users\Jimmy\source\repos\RepoLite\src\RepoLite\RepoLite.GeneratorEngine\Generators\CSharp\SQLServer\Templates\BaseRepository.tt"
 } 
            
            #line default
            #line hidden
            this.Write("            var sql = $@\"SELECT COUNT(*)\r\n                            FROM INFORMATION_SCHEMA.COLUMNS\r\n                            WHERE TABLE_NAME = '{table}' AND TABLE_SCHEMA = '{schema}'\";\r\n\r\n            using (var cn = new SqlConnection(ConnectionString))\r\n            {\r\n                using (var cmd = CreateCommand(cn, sql))\r\n                {\r\n                    try\r\n                    {\r\n                        cn.Open();\r\n                        var count = (int)cmd.ExecuteScalar();\r\n                        if (count != columns.Count)\r\n                            throw new Exception(\r\n                                \"Repository Definition does not match Database. Please re-run the code generator to get a new repository\");\r\n                    }\r\n                    finally { cn.Close(); }\r\n                }\r\n            }\r\n        }\r\n\r\n        public long RecordCount()\r\n        {\r\n            var query = BuildSelectQuery(new List<TableDefinition> { new TableDefinition(null, Schema, TableName, new[] { new ColumnDefinition(\"'x'\") }) });\r\n            var dt = Execute(query, \"1=1\");\r\n            return dt == null ? 0 : dt.Rows.Count;\r\n        }\r\n\r\n        public virtual IEnumerable<T> GetAll()\r\n        {\r\n            return Where(new List<TableDefinition> { new TableDefinition(null, Schema, TableName, Columns) }, \"1=1\");\r\n        }\r\n\r\n        public abstract bool Create(T item);\r\n        public abstract bool BulkCreate(List<T> items);\r\n        public abstract bool BulkCreate(params T[] items);\r\n        public abstract T ToItem(DataRow row, bool skipBase);\r\n        public abstract TK ToItem<TK>(DataRow row, bool skipBase) where TK : T, new();\r\n\r\n");
            
            #line 1812 "C:\Users\Jimmy\source\repos\RepoLite\src\RepoLite\RepoLite.GeneratorEngine\Generators\CSharp\SQLServer\Templates\BaseRepository.tt"
 if (generationSettings.IncludeCaching) { 
            
            #line default
            #line hidden
            this.Write("        public void EnableCache(int cacheDurationInSeconds)\r\n        {\r\n            CacheEnabled = true;\r\n            CacheDuration = cacheDurationInSeconds;\r\n            CacheHelper.Initialize(cacheDurationInSeconds);\r\n        }\r\n\r\n");
            
            #line 1820 "C:\Users\Jimmy\source\repos\RepoLite\src\RepoLite\RepoLite.GeneratorEngine\Generators\CSharp\SQLServer\Templates\BaseRepository.tt"
 } 
            
            #line default
            #line hidden
            this.Write("        private string BuildSelectQuery(List<TableDefinition> tables)\r\n        {\r\n            var sb = new StringBuilder();\r\n            sb.AppendLine(\"SELECT \");\r\n\r\n            if (tables.Count == 1)\r\n            {\r\n                var columns = tables[0].Columns;\r\n                var columnArray = columns.ToArray();\r\n                if (columnArray.Any())\r\n                {\r\n                    foreach (var column in columnArray)\r\n                    {\r\n                        sb.Append($\"{(column.ColumnName == \"'x'\" ? \"\" : \"a_0.\")}{column.ColumnName}\");\r\n                        if (column != columnArray.Last())\r\n                            sb.Append(\", \");\r\n                    }\r\n                }\r\n\r\n                sb.Append($\" FROM [{Schema}].[{TableName}] a_0\");\r\n            }\r\n            else\r\n            {\r\n                for (var i = 0; i < tables.Count; i++)\r\n                {\r\n                    var table = tables[i];\r\n\r\n                    var columns = tables[i].Columns;\r\n                    var columnArray = columns.ToArray();\r\n                    if (columnArray.Any())\r\n                    {\r\n                        foreach (var column in columnArray)\r\n                        {\r\n                            sb.Append($\"a_{i}.{column.ColumnName}\");\r\n                            sb.Append(\", \");\r\n                        }\r\n                    }\r\n                }\r\n\r\n                sb.Length -= 2;\r\n\r\n                sb.Append($\" FROM [{Schema}].[{TableName}] a_0\");\r\n\r\n                if (tables.Count > 1)\r\n                {\r\n                    for (var i = 1; i < tables.Count; i++)\r\n                    {\r\n                        var table = tables[i];\r\n\r\n                        sb.Append($\" LEFT JOIN [{table.Schema}].[{table.TableName}] a_{i}\");\r\n                        sb.Append($\" ON a_{i - 1}.{table.PrimaryKey} = a_{i}.{table.PrimaryKey}\");\r\n                    }\r\n                }\r\n            }\r\n\r\n            return sb.ToString();\r\n        }\r\n\r\n        public virtual Where<T> Where(string col, Comparison comparison, object val)\r\n        {\r\n            return Where(new List<TableDefinition> { new TableDefinition(null, Schema, TableName, Columns) }, col, comparison, val, val.GetType());\r\n        }\r\n\r\n        public virtual Where<T> Where(string col, Comparison comparison, object val, Type valueType)\r\n        {\r\n            return Where(new List<TableDefinition> { new TableDefinition(null, Schema, TableName, Columns) }, col, comparison, val, valueType);\r\n        }\r\n\r\n        public virtual IEnumerable<T> Where(string query)\r\n        {\r\n            return Where(new List<TableDefinition> { new TableDefinition(null, Schema, TableName, Columns) }, query);\r\n        }\r\n\r\n        protected Where<T> Where(List<TableDefinition> tables, string col, Comparison comparison, object val,\r\n            Type valueType)\r\n        {\r\n            return new Where<T>(this, tables, col, comparison, val, valueType);\r\n        }\r\n\r\n        protected internal virtual IEnumerable<T> Where(List<TableDefinition> tables, string query)\r\n        {\r\n            var dt = Execute(BuildSelectQuery(tables), query);\r\n            return dt == null ? new T[0] : ToItems(dt, false);\r\n        }\r\n\r\n        protected DataTable Execute(string columnPart, string filterPart)\r\n        {\r\n            if (HasInjection(columnPart) || HasInjection(filterPart))\r\n                throw new Exception(\"Sql Injection attempted. Aborted\");\r\n\r\n            return Execute($\"{columnPart} WHERE {filterPart}\");\r\n        }\r\n        protected DataTable Execute(string query)\r\n        {\r\n            if (HasInjection(query))\r\n                throw new Exception(\"Sql Injection attempted. Aborted\");\r\n\r\n            //Get\r\n            using (var cn = new SqlConnection(ConnectionString))\r\n            {\r\n                using (var cmd = CreateCommand(cn, query))\r\n                {\r\n                    if (HasInjection(cmd.CommandText))\r\n                        throw new Exception(\"Sql Injection attempted. Aborted\");\r\n\r\n                    //Execute\r\n                    cn.Open();\r\n                    var dt = ToDataTable(cmd);\r\n                    if (dt == null)\r\n                        return null;\r\n\r\n                    cn.Close();\r\n\r\n                    return dt;\r\n                }\r\n            }\r\n        }\r\n\r\n        protected IEnumerable<T> BaseSearch(List<QueryItem> queries)\r\n        {\r\n            if (!queries.Any())\r\n                return new List<T>();\r\n\r\n            var first = queries.First();\r\n            var whereQuery = Where(first.DbColumnName, Comparison.Equals, first.Value, first.DataType);\r\n\r\n            if (queries.Count > 1)\r\n            {\r\n                whereQuery = queries.Skip(1).Aggregate(whereQuery,\r\n                    (current, query) => current.And(query.DbColumnName, Comparison.Equals, query.Value, first.DataType));\r\n            }\r\n\r\n            return whereQuery.Results();\r\n        }\r\n\r\n        protected Dictionary<string, object> BaseCreate(params object[] values)\r\n        {\r\n            var returnIds = new Dictionary<string, object>();\r\n\r\n            //Creation\r\n            using (var cn = new SqlConnection(ConnectionString))\r\n            {\r\n                var sb = new StringBuilder();\r\n                var pkCols = Columns.Where(x => x.PrimaryKey).ToList();\r\n\r\n                if (Columns.Any(x => x.PrimaryKey))\r\n                {\r\n                    sb.AppendLine(\"DECLARE @tempo TABLE (\");\r\n                    foreach (var pk in pkCols)\r\n                    {\r\n                        sb.Append($\"[{pk.ColumnName}]  {pk.SqlDataTypeText}\");\r\n                        sb.AppendLine(pk != pkCols[pkCols.Count - 1] ? \",\" : string.Empty);\r\n                    }\r\n                    sb.AppendLine(\")\");\r\n                }\r\n                sb.AppendLine($\"INSERT [{Schema}].[{TableName}] (\");\r\n\r\n                var toCreate = Columns.Where(x => !x.PrimaryKey || x.PrimaryKey && !x.Identity).ToList();\r\n                foreach (var createColumn in toCreate)\r\n                {\r\n                    sb.Append($\"[{createColumn.ColumnName}]\");\r\n\r\n                    sb.AppendLine(createColumn != Columns.Last() ? \",\" : \")\");\r\n                }\r\n\r\n                if (Columns.Any(x => x.PrimaryKey))\r\n                {\r\n                    sb.Append(\"OUTPUT \");\r\n\r\n                    foreach (var pk in pkCols)\r\n                    {\r\n                        sb.Append($\"[Inserted].[{pk.ColumnName}] \");\r\n                        sb.AppendLine(pk != pkCols[pkCols.Count - 1] ? \",\" : string.Empty);\r\n                    }\r\n\r\n                    sb.AppendLine(\"INTO @tempo \");\r\n                }\r\n\r\n                sb.AppendLine(\"VALUES (\");\r\n\r\n                var valueCols = Columns.Where(x => !x.PrimaryKey || (x.PrimaryKey && !x.Identity)).ToList();\r\n                foreach (var createColumn in valueCols)\r\n                {\r\n                    sb.Append(\"@\" + createColumn.ColumnName);\r\n                    sb.AppendLine(createColumn != valueCols.Last() ? \",\" : \")\");\r\n\r\n                }\r\n\r\n                if (Columns.Any(x => x.PrimaryKey))\r\n                {\r\n                    sb.AppendLine(\"SELECT * FROM @tempo\");\r\n                }\r\n\r\n                var sql = sb.ToString();\r\n\r\n                if (HasInjection(sql))\r\n                    throw new Exception(\"Sql Injection attempted. Aborted\");\r\n\r\n                using (var cmd = CreateCommand(cn, sql))\r\n                {\r\n                    for (var i = 0; i < Columns.Count; i++)\r\n                    {\r\n                        var createColumn = Columns[i];\r\n                        if (createColumn.PrimaryKey && (!createColumn.PrimaryKey || createColumn.Identity))\r\n                            continue;\r\n\r\n                        var parameter = cmd.Parameters.Add(createColumn.ColumnName, createColumn.SqlDbType);\r\n                        parameter.Value = values[i] != null\r\n                            ? (values[i].GetType() == typeof(XmlDocument)\r\n                                ? ((XmlDocument)values[i]).InnerXml\r\n                                : values[i])\r\n                            : DBNull.Value;\r\n                    }\r\n\r\n                    DataTable dt;\r\n                    var isSuccess = ToDataTable(cmd, cn, out dt);\r\n                    //Extract the primary keys\r\n\r\n                    if (!isSuccess) return returnIds;\r\n\r\n                    if (dt.Rows.Count > 0)\r\n                    {\r\n                        for (var i = 0; i < dt.Columns.Count; i++)\r\n                        {\r\n                            var dataColumn = dt.Columns[i];\r\n                            returnIds.Add(dataColumn.ColumnName, dt.Rows[i][0]);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            return returnIds;\r\n        }\r\n\r\n        protected bool BulkInsert(DataTable dt, string tableName)\r\n        {\r\n            try\r\n            {\r\n                using (var cn = new SqlConnection(ConnectionString))\r\n                {\r\n                    cn.Open();\r\n\r\n                    //Copy to staging table\r\n                    using (var bulkCopy =\r\n                        new SqlBulkCopy(cn,\r\n                                SqlBulkCopyOptions.TableLock |\r\n                                SqlBulkCopyOptions.FireTriggers |\r\n                                SqlBulkCopyOptions.UseInternalTransaction, null)\r\n                        { DestinationTableName = tableName })\r\n                    {\r\n                        //Needed if there is an identity column on the table\r\n                        foreach (DataColumn dataColumn in dt.Columns)\r\n                        {\r\n                            bulkCopy.ColumnMappings.Add(dataColumn.ColumnName, dataColumn.ColumnName);\r\n                        }\r\n\r\n                        bulkCopy.WriteToServer(dt);\r\n                    }\r\n\r\n                    cn.Close();\r\n                    return true;\r\n                }\r\n            }\r\n            catch (Exception ex)\r\n            {\r\n                Logger(ex);\r\n                return false;\r\n            }\r\n        }\r\n\r\n        protected bool BulkInsert(DataTable dt)\r\n        {\r\n            return BulkInsert(dt, $\"[{Schema}].[{TableName}]\");\r\n        }\r\n\r\n        protected bool BaseUpdate(List<string> dirtyColumns, params object[] values)\r\n        {\r\n            bool isSuccess;\r\n\r\n            var sb = new StringBuilder();\r\n            sb.AppendLine($\"UPDATE [{Schema}].[{TableName}] SET\");\r\n\r\n            var nonpkCols = Columns.Where(x => !x.PrimaryKey).ToArray();\r\n            \r\n            var updateCols = nonpkCols.Where(x => dirtyColumns.Contains(x.ColumnName)).ToList();\r\n            //No columns tro update on this model, must be updating a derived class\r\n            if (!updateCols.Any()) return true;\r\n            foreach (var col in updateCols)\r\n            {\r\n                sb.Append($\"[{col.ColumnName}] = @{col.ColumnName}\");\r\n                sb.AppendLine(col != nonpkCols.Last(x => dirtyColumns.Contains(x.ColumnName)) ? \",\" : \"\");\r\n            }\r\n            sb.AppendLine(\"WHERE\");\r\n\r\n            var pkCols = Columns.Where(x => x.PrimaryKey).ToArray();\r\n            foreach (var pk in pkCols)\r\n            {\r\n                sb.AppendLine(pk == pkCols.First()\r\n                    ? $\"[{pk.ColumnName}] = @{pk.ColumnName}\"\r\n                        : $\"AND [{pk.ColumnName}] = @{pk.ColumnName}\");\r\n            }\r\n\r\n            var sql = sb.ToString();\r\n\r\n            if (HasInjection(sql))\r\n                throw new Exception(\"Sql Injection attempted. Aborted\");\r\n\r\n            //Creation\r\n            using (var cn = new SqlConnection(ConnectionString))\r\n            {\r\n                using (var cmd = CreateCommand(cn, sql))\r\n                {\r\n                    for (var i = 0; i < Columns.Count; i++)\r\n                    {\r\n                        var updateColumn = Columns[i];\r\n                        if (!dirtyColumns.Contains(updateColumn.ColumnName) && !updateColumn.PrimaryKey) continue;\r\n\r\n                        var parameter = cmd.Parameters.Add(updateColumn.ColumnName, updateColumn.SqlDbType);\r\n                        if (updateColumn.PrimaryKey)\r\n                        {\r\n                            parameter.Value = values[i];\r\n                        }\r\n                        else\r\n                        {\r\n                            parameter.Value = dirtyColumns.Contains(updateColumn.ColumnName) ? values[i] ?? DBNull.Value : values[i];\r\n                        }\r\n                    }\r\n\r\n                    //Execute\r\n                    isSuccess = NoneQuery(cn, cmd);\r\n                }\r\n            }\r\n\r\n            return isSuccess;\r\n        }\r\n\r\n        protected bool BaseDelete(DeleteColumn deleteColumn, out IEnumerable<T> items)\r\n        {\r\n            bool isSuccess;\r\n\r\n            //Creation\r\n            using (var cn = new SqlConnection(ConnectionString))\r\n            {\r\n\r\n                var sb = new StringBuilder();\r\n                sb.Append(@\"DECLARE @MyTableVar TABLE (\");\r\n\r\n                foreach (var mergeColumn in Columns)\r\n                {\r\n                    sb.Append($\"[{mergeColumn.ColumnName}] {mergeColumn.SqlDataTypeText} NULL\");\r\n\r\n                    sb.AppendLine(mergeColumn != Columns[Columns.Count - 1] ? \",\" : \")\");\r\n                }\r\n\r\n                sb.Append($\"DELETE [{Schema}].[{TableName}] \");\r\n                sb.Append(\"OUTPUT DELETED.* INTO @MyTableVar \");\r\n                sb.Append($\"WHERE [{ deleteColumn.ColumnName}] = @{deleteColumn.ColumnName};\");\r\n                sb.Append($\"SELECT * FROM @MyTableVar\");\r\n\r\n                var sql = sb.ToString();\r\n                if (HasInjection(sql))\r\n                    throw new Exception(\"Sql Injection attempted. Aborted\");\r\n\r\n                using (var cmd = CreateCommand(cn, sql))\r\n                {\r\n                    var parameter = cmd.Parameters.Add(deleteColumn.ColumnName, deleteColumn.SqlDbType);\r\n                    parameter.Value = deleteColumn.Data;\r\n\r\n                    //Execute\r\n                    DataTable dt;\r\n                    isSuccess = ToDataTable(cmd, cn, out dt);\r\n\r\n                    items = null;\r\n                    if (!isSuccess) return false;\r\n\r\n                    items = ToItems(dt, true);\r\n                    return true;\r\n\r\n                }\r\n            }\r\n        }\r\n\r\n        protected bool BaseDelete(string columnName, List<object> dataValues)\r\n        {\r\n            bool isSuccess;\r\n\r\n\r\n            //Creation\r\n            using (var cn = new SqlConnection(ConnectionString))\r\n            {\r\n                var sb = new StringBuilder();\r\n\r\n                sb.Append($\"DELETE [{Schema}].[{TableName}] WHERE [{columnName}] IN (\");\r\n\r\n                foreach (var dataValue in dataValues)\r\n                {\r\n                    sb.Append(dataValue);\r\n                    if (dataValue != dataValues.Last())\r\n                        sb.Append(\", \");\r\n                }\r\n\r\n                sb.Append(\")\");\r\n\r\n                var sql = sb.ToString();\r\n                if (HasInjection(sql))\r\n                    throw new Exception(\"Sql Injection attempted. Aborted\");\r\n\r\n                using (var cmd = CreateCommand(cn, sql))\r\n                {\r\n                    isSuccess = NoneQuery(cn, cmd);\r\n                }\r\n            }\r\n\r\n            return isSuccess;\r\n        }\r\n\r\n        protected bool BaseMerge(List<object[]> mergeData)\r\n        {\r\n            return BaseMerge(mergeData, Columns, Schema, TableName);\r\n        }\r\n\r\n        protected bool BaseMerge(List<object[]> mergeData, List<ColumnDefinition> columns, string schema, string tableName)\r\n        {\r\n            var tempTableName = \"staging\" + DateTime.Now.Ticks;\r\n\r\n            try\r\n            {\r\n                var dt = new DataTable();\r\n                foreach (var mergeColumn in columns)\r\n                {\r\n                    dt.Columns.Add(mergeColumn.ColumnName, mergeColumn.ValueType);\r\n                    if (!mergeColumn.PrimaryKey)\r\n                        dt.Columns.Add(mergeColumn.ColumnName + \"Changed\", typeof(bool));\r\n                }\r\n\r\n                foreach (var data in mergeData)\r\n                {\r\n                    dt.Rows.Add(data);\r\n                }\r\n\r\n                CreateStagingTable(tempTableName, columns);\r\n                BulkInsert(dt, tempTableName);\r\n\r\n                using (var cn = new SqlConnection(ConnectionString))\r\n                {\r\n                    var mergeSql = new StringBuilder();\r\n                    mergeSql.AppendLine($\"MERGE INTO [{schema}].[{tableName}] AS [Target]\");\r\n                    mergeSql.AppendLine($\"USING {tempTableName} AS Source\");\r\n                    mergeSql.AppendLine(\"ON\");\r\n\r\n                    var pks = columns.Where(x => x.PrimaryKey).ToArray();\r\n\r\n                    foreach (var pk in pks)\r\n                    {\r\n                        if (pk != pks.First())\r\n                            mergeSql.Append(\"AND \");\r\n                        mergeSql.AppendLine($\"[Target].[{pk.ColumnName}] = [Source].[{pk.ColumnName}]\");\r\n                    }\r\n\r\n\r\n                    mergeSql.AppendLine(\"WHEN MATCHED THEN UPDATE SET\");\r\n\r\n                    var nonpks = columns.Where(x => !x.PrimaryKey).ToArray();\r\n\r\n                    foreach (var mergeColumn in nonpks)\r\n                    {\r\n                        mergeSql.Append(\r\n                            $\"[Target].[{mergeColumn.ColumnName}] = CASE WHEN [Source].[{mergeColumn.ColumnName}Changed] = 1 THEN [Source].[{mergeColumn.ColumnName}] ELSE [Target].[{mergeColumn.ColumnName}] END\");\r\n\r\n                        mergeSql.AppendLine(mergeColumn != nonpks.Last() ? \",\" : Environment.NewLine);\r\n                    }\r\n\r\n                    mergeSql.AppendLine(\"WHEN NOT MATCHED THEN INSERT (\");\r\n\r\n                    mergeSql.AppendLine(string.Join(\",\", columns.Where(x => !x.Identity).Select(x => $\"[{x.ColumnName}]\").ToArray()) + \")\");\r\n                    mergeSql.AppendLine(\"VALUES (\");\r\n                    mergeSql.AppendLine(string.Join(\",\", columns.Where(x => !x.Identity).Select(x => $\"[Source].[{x.ColumnName}]\").ToArray()) + \");\");\r\n                    mergeSql.AppendLine(\"IF OBJECT_ID('dbo.DropTmpTable') IS NULL EXEC ('CREATE PROCEDURE dbo.DropTmpTable @table NVARCHAR(250) AS DECLARE @sql NVARCHAR(300) = N''DROP TABLE '' + @table; EXECUTE sp_executesql @sql')\");\r\n\r\n                    var sql = mergeSql.ToString();\r\n                    if (HasInjection(sql))\r\n                        throw new Exception(\"Sql Injection attempted. Aborted\");\r\n\r\n                    //Merge data\r\n                    var cmd = new SqlCommand\r\n                    {\r\n                        Connection = cn,\r\n                        CommandType = CommandType.Text,\r\n                        CommandText = sql\r\n                    };\r\n\r\n                    cn.Open();\r\n                    cmd.ExecuteNonQuery();\r\n                    cmd.Dispose();\r\n\r\n                    var dropCmd = new SqlCommand\r\n                    {\r\n                        Connection = cn,\r\n                        CommandType = CommandType.StoredProcedure,\r\n                        CommandText = \"dbo.DropTmpTable\"\r\n                    };\r\n\r\n                    dropCmd.Parameters.AddWithValue(\"table\", tempTableName);\r\n                    dropCmd.ExecuteNonQuery();\r\n                    dropCmd.Dispose();\r\n                    cn.Close();\r\n\r\n                    return true;\r\n                }\r\n            }\r\n            catch (Exception ex)\r\n            {\r\n                Logger(ex);\r\n                using (var cn = new SqlConnection(ConnectionString))\r\n                {\r\n                    var cmd = new SqlCommand\r\n                    {\r\n                        Connection = cn,\r\n                        CommandType = CommandType.Text,\r\n                        CommandText = $\"DROP TABLE {tempTableName}\"\r\n                    };\r\n\r\n                    try\r\n                    {\r\n                        cmd.ExecuteNonQuery();\r\n                    }\r\n                    catch (Exception ex2) { Logger(ex2); }\r\n                }\r\n                return false;\r\n            }\r\n        }\r\n\r\n        public IOnClause<T, T2> InnerJoin<T2>() where T2 : IBaseModel, new()\r\n        {\r\n            var onClause = new OnClause<T, T2>(ConnectionString, JoinType.Inner);\r\n            return onClause;\r\n        }\r\n\r\n        public IOnClause<T, T2> LeftJoin<T2>() where T2 : IBaseModel, new()\r\n        {\r\n            var onClause = new OnClause<T, T2>(ConnectionString, JoinType.Left);\r\n            return onClause;\r\n        }\r\n\r\n        public IOnClause<T, T2> RightJoin<T2>() where T2 : IBaseModel, new()\r\n        {\r\n            var onClause = new OnClause<T, T2>(ConnectionString, JoinType.Right);\r\n            return onClause;\r\n        }\r\n\r\n        public IOnClause<T, T2> FullJoin<T2>() where T2 : IBaseModel, new()\r\n        {\r\n            var onClause = new OnClause<T, T2>(ConnectionString, JoinType.Full);\r\n            return onClause;\r\n        }\r\n\r\n        protected IEnumerable<T> ToItems(DataTable table, bool skipBase)\r\n        {\r\n            foreach (DataRow row in table.Rows)\r\n            {\r\n                var item = default(T);\r\n                try\r\n                {\r\n                    item = ToItem(row, skipBase);\r\n                }\r\n                catch (Exception ex)\r\n                {\r\n                    Logger(ex);\r\n                }\r\n                yield return item;\r\n            }\r\n        }\r\n\r\n        protected bool NoneQuery(SqlConnection cn, SqlCommand cmd)\r\n        {\r\n            if (HasInjection(cmd.CommandText))\r\n                throw new Exception(\"Sql Injection attempted. Aborted\");\r\n\r\n            var isSuccess = true;\r\n            cn.Open();\r\n            try\r\n            {\r\n                cmd.ExecuteNonQuery();\r\n            }\r\n            catch (Exception ex)\r\n            {\r\n                Logger(ex);\r\n                isSuccess = false;\r\n            }\r\n            cn.Close();\r\n            return isSuccess;\r\n        }\r\n\r\n\r\n\r\n        protected bool GetBoolean(DataRow row, string fieldName)\r\n        {\r\n            return row.GetValue<bool>(fieldName) ?? false;\r\n        }\r\n\r\n        protected bool? GetNullableBoolean(DataRow row, string fieldName)\r\n        {\r\n            return row.GetValue<bool>(fieldName);\r\n        }\r\n\r\n        protected short GetInt16(DataRow row, string fieldName)\r\n        {\r\n            return row.GetValue<short>(fieldName) ?? default(Int16);\r\n        }\r\n\r\n        protected short? GetNullableInt16(DataRow row, string fieldName)\r\n        {\r\n            return row.GetValue<short>(fieldName);\r\n        }\r\n\r\n        protected int GetInt32(DataRow row, string fieldName)\r\n        {\r\n            return row.GetValue<int>(fieldName) ?? default(Int32);\r\n        }\r\n\r\n        protected int? GetNullableInt32(DataRow row, string fieldName)\r\n        {\r\n            return row.GetValue<int>(fieldName);\r\n        }\r\n\r\n        protected long GetInt64(DataRow row, string fieldName)\r\n        {\r\n            return row.GetValue<long>(fieldName) ?? default(Int64);\r\n        }\r\n\r\n        protected long? GetNullableInt64(DataRow row, string fieldName)\r\n        {\r\n            return row.GetValue<long>(fieldName);\r\n        }\r\n\r\n        protected decimal GetDecimal(DataRow row, string fieldName)\r\n        {\r\n            return row.GetValue<decimal>(fieldName) ?? default(decimal);\r\n        }\r\n\r\n        protected decimal? GetNullableDecimal(DataRow row, string fieldName)\r\n        {\r\n            return row.GetValue<decimal>(fieldName);\r\n        }\r\n\r\n        protected double GetDouble(DataRow row, string fieldName)\r\n        {\r\n            return row.GetValue<double>(fieldName) ?? default(double);\r\n        }\r\n\r\n        protected double? GetNullableDouble(DataRow row, string fieldName)\r\n        {\r\n            return row.GetValue<double>(fieldName);\r\n        }\r\n\r\n        protected DateTime GetDateTime(DataRow row, string fieldName)\r\n        {\r\n            return row.GetValue<DateTime>(fieldName) ?? default(DateTime);\r\n        }\r\n\r\n        protected DateTime? GetNullableDateTime(DataRow row, string fieldName)\r\n        {\r\n            return row.GetValue<DateTime>(fieldName);\r\n        }\r\n\r\n        protected byte GetByte(DataRow row, string fieldName)\r\n        {\r\n            return (byte)row[fieldName];\r\n        }\r\n\r\n        protected byte? GetNullableByte(DataRow row, string fieldName)\r\n        {\r\n            return row[fieldName] as byte?;\r\n        }\r\n\r\n        protected byte[] GetByteArray(DataRow row, string fieldName)\r\n        {\r\n            return row[fieldName] as byte[];\r\n        }\r\n\r\n        protected DateTimeOffset GetDateTimeOffset(DataRow row, string fieldName)\r\n        {\r\n            return row.GetValue<DateTimeOffset>(fieldName) ?? default(DateTimeOffset);\r\n        }\r\n\r\n        protected DateTimeOffset? GetNullableDateTimeOffset(DataRow row, string fieldName)\r\n        {\r\n            return row.GetValue<DateTimeOffset>(fieldName);\r\n        }\r\n\r\n        protected Guid GetGuid(DataRow row, string fieldName)\r\n        {\r\n            return row.GetValue<Guid>(fieldName) ?? Guid.Empty;\r\n        }\r\n\r\n        protected Guid? GetNullableGuid(DataRow row, string fieldName)\r\n        {\r\n            return row.GetValue<Guid>(fieldName);\r\n        }\r\n\r\n        protected TimeSpan GetTimeSpan(DataRow row, string fieldName)\r\n        {\r\n            return row.GetValue<TimeSpan>(fieldName) ?? default(TimeSpan);\r\n        }\r\n\r\n        protected TimeSpan? GetNullableTimeSpan(DataRow row, string fieldName)\r\n        {\r\n            return row.GetValue<TimeSpan>(fieldName);\r\n        }\r\n\r\n        protected XmlDocument GetXmlDocument(DataRow row, string fieldName)\r\n        {\r\n            return new XmlDocument\r\n            {\r\n                InnerXml = row.Table.Columns.Contains(fieldName) ? row.GetText(fieldName) : \"\"\r\n            };\r\n        }\r\n\r\n        protected string GetString(DataRow row, string fieldName)\r\n        {\r\n            return row.Table.Columns.Contains(fieldName) ? row.GetText(fieldName) : default(string);\r\n        }\r\n\r\n        protected TType Cast<TType>(object value)\r\n        {\r\n            if (value is TType tVal)\r\n            {\r\n                return tVal;\r\n            }\r\n            try\r\n            {\r\n                if (typeof(TType) == typeof(Boolean) && (value.ToString() == \"1\" || value.ToString() == \"0\"))\r\n                    return (TType)Convert.ChangeType(value.ToString() == \"1\", typeof(TType));\r\n                return (TType)Convert.ChangeType(value, typeof(TType));\r\n            }\r\n            catch (InvalidCastException)\r\n            {\r\n                return default(TType);\r\n            }\r\n        }\r\n\r\n        public IEnumerable<T> ExecuteSql(string sql)\r\n        {\r\n            return ToItems(Execute(sql), false);\r\n        }\r\n\r\n        #region [Private]\r\n\r\n        protected void CreateStagingTable(string tempTableName, List<ColumnDefinition> columns, bool onlyPrimaryKeys = false)\r\n        {\r\n            var stagingSqlBuilder = new StringBuilder();\r\n            stagingSqlBuilder.AppendLine(@\"CREATE TABLE \" + tempTableName + \" (\");\r\n            foreach (var mergeColumn in columns.Where(x => onlyPrimaryKeys && x.PrimaryKey || !onlyPrimaryKeys))\r\n            {\r\n                stagingSqlBuilder.Append($\"[{mergeColumn.ColumnName}] {mergeColumn.SqlDataTypeText} NULL\");\r\n\r\n                if (!mergeColumn.PrimaryKey)\r\n                {\r\n                    stagingSqlBuilder.AppendLine(\",\");\r\n                    stagingSqlBuilder.Append($\"[{mergeColumn.ColumnName}Changed] [BIT] NOT NULL\");\r\n                }\r\n                stagingSqlBuilder.AppendLine(mergeColumn != columns[columns.Count - 1] ? \",\" : \")\");\r\n            }\r\n\r\n            var stagingSql = stagingSqlBuilder.ToString();\r\n            if (HasInjection(stagingSql))\r\n                throw new Exception(\"Sql Injection attempted. Aborted\");\r\n\r\n            using (var cn = new SqlConnection(ConnectionString))\r\n            {\r\n                //Create staging table\r\n                var cmd = new SqlCommand\r\n                {\r\n                    Connection = cn,\r\n                    CommandType = CommandType.Text,\r\n                    CommandText = stagingSql\r\n                };\r\n                cn.Open();\r\n                cmd.ExecuteNonQuery();\r\n            }\r\n        }\r\n\r\n        #endregion\r\n    }\r\n}\r\n");
            return this.GenerationEnvironment.ToString();
        }
        
        #line 1 "C:\Users\Jimmy\source\repos\RepoLite\src\RepoLite\RepoLite.GeneratorEngine\Generators\CSharp\SQLServer\Templates\BaseRepository.tt"

private global::RepoLite.Common.Options.GenerationOptions _generationSettingsField;

/// <summary>
/// Access the generationSettings parameter of the template.
/// </summary>
private global::RepoLite.Common.Options.GenerationOptions generationSettings
{
    get
    {
        return this._generationSettingsField;
    }
}


/// <summary>
/// Initialize the template
/// </summary>
public virtual void Initialize()
{
    if ((this.Errors.HasErrors == false))
    {
bool generationSettingsValueAcquired = false;
if (this.Session.ContainsKey("generationSettings"))
{
    this._generationSettingsField = ((global::RepoLite.Common.Options.GenerationOptions)(this.Session["generationSettings"]));
    generationSettingsValueAcquired = true;
}
if ((generationSettingsValueAcquired == false))
{
    object data = global::System.Runtime.Remoting.Messaging.CallContext.LogicalGetData("generationSettings");
    if ((data != null))
    {
        this._generationSettingsField = ((global::RepoLite.Common.Options.GenerationOptions)(data));
    }
}


    }
}


        
        #line default
        #line hidden
    }
    
    #line default
    #line hidden
    #region Base class
    /// <summary>
    /// Base class for this transformation
    /// </summary>
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.VisualStudio.TextTemplating", "16.0.0.0")]
    public class BaseRepositoryBase
    {
        #region Fields
        private global::System.Text.StringBuilder generationEnvironmentField;
        private global::System.CodeDom.Compiler.CompilerErrorCollection errorsField;
        private global::System.Collections.Generic.List<int> indentLengthsField;
        private string currentIndentField = "";
        private bool endsWithNewline;
        private global::System.Collections.Generic.IDictionary<string, object> sessionField;
        #endregion
        #region Properties
        /// <summary>
        /// The string builder that generation-time code is using to assemble generated output
        /// </summary>
        protected System.Text.StringBuilder GenerationEnvironment
        {
            get
            {
                if ((this.generationEnvironmentField == null))
                {
                    this.generationEnvironmentField = new global::System.Text.StringBuilder();
                }
                return this.generationEnvironmentField;
            }
            set
            {
                this.generationEnvironmentField = value;
            }
        }
        /// <summary>
        /// The error collection for the generation process
        /// </summary>
        public System.CodeDom.Compiler.CompilerErrorCollection Errors
        {
            get
            {
                if ((this.errorsField == null))
                {
                    this.errorsField = new global::System.CodeDom.Compiler.CompilerErrorCollection();
                }
                return this.errorsField;
            }
        }
        /// <summary>
        /// A list of the lengths of each indent that was added with PushIndent
        /// </summary>
        private System.Collections.Generic.List<int> indentLengths
        {
            get
            {
                if ((this.indentLengthsField == null))
                {
                    this.indentLengthsField = new global::System.Collections.Generic.List<int>();
                }
                return this.indentLengthsField;
            }
        }
        /// <summary>
        /// Gets the current indent we use when adding lines to the output
        /// </summary>
        public string CurrentIndent
        {
            get
            {
                return this.currentIndentField;
            }
        }
        /// <summary>
        /// Current transformation session
        /// </summary>
        public virtual global::System.Collections.Generic.IDictionary<string, object> Session
        {
            get
            {
                return this.sessionField;
            }
            set
            {
                this.sessionField = value;
            }
        }
        #endregion
        #region Transform-time helpers
        /// <summary>
        /// Write text directly into the generated output
        /// </summary>
        public void Write(string textToAppend)
        {
            if (string.IsNullOrEmpty(textToAppend))
            {
                return;
            }
            // If we're starting off, or if the previous text ended with a newline,
            // we have to append the current indent first.
            if (((this.GenerationEnvironment.Length == 0) 
                        || this.endsWithNewline))
            {
                this.GenerationEnvironment.Append(this.currentIndentField);
                this.endsWithNewline = false;
            }
            // Check if the current text ends with a newline
            if (textToAppend.EndsWith(global::System.Environment.NewLine, global::System.StringComparison.CurrentCulture))
            {
                this.endsWithNewline = true;
            }
            // This is an optimization. If the current indent is "", then we don't have to do any
            // of the more complex stuff further down.
            if ((this.currentIndentField.Length == 0))
            {
                this.GenerationEnvironment.Append(textToAppend);
                return;
            }
            // Everywhere there is a newline in the text, add an indent after it
            textToAppend = textToAppend.Replace(global::System.Environment.NewLine, (global::System.Environment.NewLine + this.currentIndentField));
            // If the text ends with a newline, then we should strip off the indent added at the very end
            // because the appropriate indent will be added when the next time Write() is called
            if (this.endsWithNewline)
            {
                this.GenerationEnvironment.Append(textToAppend, 0, (textToAppend.Length - this.currentIndentField.Length));
            }
            else
            {
                this.GenerationEnvironment.Append(textToAppend);
            }
        }
        /// <summary>
        /// Write text directly into the generated output
        /// </summary>
        public void WriteLine(string textToAppend)
        {
            this.Write(textToAppend);
            this.GenerationEnvironment.AppendLine();
            this.endsWithNewline = true;
        }
        /// <summary>
        /// Write formatted text directly into the generated output
        /// </summary>
        public void Write(string format, params object[] args)
        {
            this.Write(string.Format(global::System.Globalization.CultureInfo.CurrentCulture, format, args));
        }
        /// <summary>
        /// Write formatted text directly into the generated output
        /// </summary>
        public void WriteLine(string format, params object[] args)
        {
            this.WriteLine(string.Format(global::System.Globalization.CultureInfo.CurrentCulture, format, args));
        }
        /// <summary>
        /// Raise an error
        /// </summary>
        public void Error(string message)
        {
            System.CodeDom.Compiler.CompilerError error = new global::System.CodeDom.Compiler.CompilerError();
            error.ErrorText = message;
            this.Errors.Add(error);
        }
        /// <summary>
        /// Raise a warning
        /// </summary>
        public void Warning(string message)
        {
            System.CodeDom.Compiler.CompilerError error = new global::System.CodeDom.Compiler.CompilerError();
            error.ErrorText = message;
            error.IsWarning = true;
            this.Errors.Add(error);
        }
        /// <summary>
        /// Increase the indent
        /// </summary>
        public void PushIndent(string indent)
        {
            if ((indent == null))
            {
                throw new global::System.ArgumentNullException("indent");
            }
            this.currentIndentField = (this.currentIndentField + indent);
            this.indentLengths.Add(indent.Length);
        }
        /// <summary>
        /// Remove the last indent that was added with PushIndent
        /// </summary>
        public string PopIndent()
        {
            string returnValue = "";
            if ((this.indentLengths.Count > 0))
            {
                int indentLength = this.indentLengths[(this.indentLengths.Count - 1)];
                this.indentLengths.RemoveAt((this.indentLengths.Count - 1));
                if ((indentLength > 0))
                {
                    returnValue = this.currentIndentField.Substring((this.currentIndentField.Length - indentLength));
                    this.currentIndentField = this.currentIndentField.Remove((this.currentIndentField.Length - indentLength));
                }
            }
            return returnValue;
        }
        /// <summary>
        /// Remove any indentation
        /// </summary>
        public void ClearIndent()
        {
            this.indentLengths.Clear();
            this.currentIndentField = "";
        }
        #endregion
        #region ToString Helpers
        /// <summary>
        /// Utility class to produce culture-oriented representation of an object as a string.
        /// </summary>
        public class ToStringInstanceHelper
        {
            private System.IFormatProvider formatProviderField  = global::System.Globalization.CultureInfo.InvariantCulture;
            /// <summary>
            /// Gets or sets format provider to be used by ToStringWithCulture method.
            /// </summary>
            public System.IFormatProvider FormatProvider
            {
                get
                {
                    return this.formatProviderField ;
                }
                set
                {
                    if ((value != null))
                    {
                        this.formatProviderField  = value;
                    }
                }
            }
            /// <summary>
            /// This is called from the compile/run appdomain to convert objects within an expression block to a string
            /// </summary>
            public string ToStringWithCulture(object objectToConvert)
            {
                if ((objectToConvert == null))
                {
                    throw new global::System.ArgumentNullException("objectToConvert");
                }
                System.Type t = objectToConvert.GetType();
                System.Reflection.MethodInfo method = t.GetMethod("ToString", new System.Type[] {
                            typeof(System.IFormatProvider)});
                if ((method == null))
                {
                    return objectToConvert.ToString();
                }
                else
                {
                    return ((string)(method.Invoke(objectToConvert, new object[] {
                                this.formatProviderField })));
                }
            }
        }
        private ToStringInstanceHelper toStringHelperField = new ToStringInstanceHelper();
        /// <summary>
        /// Helper to produce culture-oriented representation of an object as a string
        /// </summary>
        public ToStringInstanceHelper ToStringHelper
        {
            get
            {
                return this.toStringHelperField;
            }
        }
        #endregion
    }
    #endregion
}
